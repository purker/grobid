<?xml version="1.0" ?>
<tei>
	<teiHeader>
		<fileDesc xml:id="4"/>
	</teiHeader>
	<text xml:lang="en">
			<head>KAPITEL 1<lb/></head>

			<head>Einleitung<lb/></head>

			<head>1.1 Generalized Minimum Spanning Tree-Problem<lb/></head>

			<p>Das Generalized Minimum Spanning Tree-Problem (GMST) ist ein kombinatorisches<lb/> Optimierungsproblem, das eine Verallgemeinerung des Minimum Spanning Tree Prob-<lb/>lems (MST) ist. Für das MST-Problem ist ein vollständiger Graph G gegeben, bei<lb/> dem jeder Kante Kosten zugeordnet sind. Eine Lösung des MST-Problems entspricht<lb/> einer Teilmenge von Kanten, die einen minimalen Spannbaum bilden. Ein minimaler<lb/> Spannbaum ist ein kreisfreier Teilgraph von G, der mit allen Knoten des Graphen ver-<lb/>bunden ist und dessen Summe der Kantenkosten minimal ist. Beim GMST-Problem<lb/> werden zusätzlich noch die Knoten des MST-Problems durch Cluster partitioniert.<lb/> Die formale Definition des GMST-Problems sieht wie folgt aus <ref type="biblio">[4]</ref>:<lb/></p>

			<p>Gegeben ist ein vollständiger gewichteter Graph G = (V, E, c), wobei V die Knoten-<lb/>menge, E die Kantenmenge und c : E → R<lb/> + die Kostenfunktion ist. Die Knotenmenge<lb/> V ist partitioniert in m paarweise disjunkte Cluster V 1 , V 2 , . . . , V m , wobei<lb/> i=1,...,m V i =<lb/> V , V i ∩ V j = ∅ ∀i, j = 1, . . . , m, i = j. d i ist die Anzahl der Knoten in Cluster<lb/> V i , i = 1, . . . , m. Eine Lösung für das GMST-Problem ist ein Graph S = (P, T ),<lb/> wobei P = {p 1 , p 2 , . . . , p m } ⊆ V enthält genau einen Knoten von jedem Cluster<lb/> (p i ∈ V i f or all i = 1, . . . , m). T ⊆ E ist ein Spannbaum auf die Knoten in P .<lb/> Die Kosten von T ergeben sich aus den Kantenkosten, C(T ) =<lb/> (u,v)∈T c(u, v). Die<lb/> optimale Lösung ist dann ein Graph S = (P, T ) dessen Kosten C(T ) minimal sind. Ein<lb/> Beispiel für eine solche Lösung ist in <ref type="figure">Abb. 1</ref> zu finden.<lb/></p>

			<figure>Abb. 1: Lösung für ein GMST-Problem<lb/></figure>

			<head>1.2 Evolutionäre Algorithmen<lb/></head>

			<p>Ein Evolutionärer Algorithmus (EA) <ref type="biblio">[9]</ref> ist eine Metaheuristik, mit deren Hilfe Opti-<lb/>mierungsprobleme gelöst werden können. Der EA macht sich die Eigenschaften der<lb/> natürlichen Evolution zunutze, um ausgehend von einer Anfangspopulation im Laufe<lb/> der Zeit immer bessere Lösungen zu finden. Dazu werden drei Operationen angewen-<lb/>det: Selektion, Mutation und Rekombination.<lb/></p>

			<p>Der EA arbeitet mit einer Population von Lösungen, wobei die einzelnen Lösungen<lb/> in kodierter Form gespeichert werden. Diese kodierten Lösungen werden Genotyp<lb/> genannt. Sie bestehen oft aus einem Bitstring. In dieser Arbeit werden die Lösungen<lb/> aber als Integer-Vektor gespeichert. Auf die Kodierungsarten wird in Kapitel 1.4 noch<lb/> genauer eingegangen. Um die Lösungen auswerten zu können ist es notwendig, die<lb/> Lösungen auch wieder zu dekodieren. Die dekodierten Lösungen werden Phänotypen<lb/> genannt.<lb/></p>

			<p>Der Ablauf des EA ist wie folgt: Zunächst wird für jede Lösung der Population aus<lb/> den dazugehörigen Phänotypen ein Fitnesswert berechnet. Dieser Fitnesswert ist ein<lb/> Maß dafür wie gut die Lösung ist. Danach werden durch eine Selektionsfunktion mit<lb/> Hilfe der Fitnesswerte, zwei Elternlösungen ausgewählt. Aus diesen beiden Elternlö-<lb/>sungen wird dann durch eine Rekombination eine neue Lösung generiert. Die Idee<lb/> dabei ist, dass die guten Teile der ausgewählten Lösungen zusammengesetzt werden<lb/> und dadurch eine neue bessere Lösung entsteht. Danach wird eine Mutation angewen-<lb/>det, in der die Lösung zufällig an einer bestimmten Stelle verändert wird, um nicht so<lb/> schnell in einem lokalen Optimum festzustecken. Die Mutation wird aber nur mit einer<lb/> bestimmten Wahrscheinlichkeit ausgeführt, da sonst der Zufall einen zu großen Einfluss<lb/> auf die Lösungsfindung hat.<lb/></p>

			<p>Wie bei den meisten Metaheuristiken, ist die Definition der einzelnen Methoden all-<lb/>gemein gehalten. Um den EA auf ein spezifisches Problem anzuwenden, müssen diese<lb/> Methoden angepasst werden.<lb/> Es gibt zwei unterschiedliche Arten von EAs:<lb/></p>

			<list>
				<item>• Steady-State-EA: Dabei wird in jedem Generationsschritt nur eine Lösung aus<lb/> der Population ersetzt. Die restlichen Lösungen bleiben erhalten.<lb/></item>
				<item>• generationalen-EA: Hier wird in jedem Generationsschritt die gesamte Population<lb/> ersetzt.<lb/></item>
			</list>

			<p>In dieser Arbeit, genauso wie in den Arbeiten von Sonnleitner <ref type="biblio">[13]</ref> und Wolf <ref type="biblio">[15]</ref>, auf<lb/> denen diese Arbeit aufbaut, wurde ein Steady-State-EA verwendet.<lb/></p>

			<head>1.3 Lösungsarchive<lb/></head>

			<p>Bei einem EA werden neue Lösungen durch Kombination von alten Lösungen, die sich<lb/> in der Population befinden, erzeugt. Das kann dazu führen, dass eine neu generierte Lö-<lb/>sung sich schon in der Population befindet bzw. früher schon einmal untersucht wurde.<lb/> Daraus können sich zwei Probleme ergeben. Zum einen führt es dazu, dass die sel-<lb/>ben Lösungen mehrmals evaluiert werden und somit unnötig Laufzeit verbraucht wird,<lb/> da die erneute Evaluierung keinen Sinn macht. Zum anderen kann das mehrfache be-<lb/>trachten der selben Lösungen zu einem Diversitätsverlust führen, d.h. dass sich die<lb/> Lösungen in der Population nach kurzer Zeit kaum mehr unterscheiden. Das führt dazu,<lb/> dass der Lösungsraum nicht mehr so breit durchsucht wird und man so auch schneller<lb/> in einem lokalen Optimum hängen bleibt.<lb/></p>

			<p>Um diesen Problemen entgegen zu wirken, sollte bei jeder generierten Lösung überprüft<lb/> werden, ob diese in früheren Generationen schon einmal erzeugt worden ist. Dazu rei-<lb/>cht es aber nicht die Lösungen mit der aktuellen Population zu vergleichen, da hier nur<lb/> ein kleiner Ausschnitt der bisher untersuchten Lösungen enthalten ist. Daher wird eine<lb/> Speicherstruktur verwendet, die Lösungsarchiv <ref type="biblio">[12]</ref> genannt wird, in der jede generierte<lb/> Lösung gespeichert wird und in angemessener Zeit danach gesucht werden kann.<lb/></p>

			<p>Das Lösungsarchiv muss drei Eigenschaften erfüllen. Es muss in angemessener Zeit<lb/> überprüft werden können ob eine Lösung im Archiv vorhanden ist. Außerdem soll aus<lb/> einer Lösung, die im Archiv enthalten ist, schnell eine neue Lösung generiert werden<lb/> können, die der alten möglichst ähnlich ist. Zusätzlich sollen die beiden Aufgaben mit<lb/> einem angemessenen Speicherverbrauch realisiert werden.<lb/></p>

			<p>Wie ein Lösungsarchiv in einem EA verwendet wird, ist in <ref type="table">Algorithmus 1</ref> dargestellt.<lb/> Dieser Algorithmus wurde aus <ref type="biblio">[13]</ref> übernommen.<lb/> Die Frage, welche Datenstruktur sich am besten für ein Lösungsarchiv eignet, wurde<lb/> in den Arbeiten von Zaubzer <ref type="biblio">[16]</ref> und Šramko <ref type="biblio">[14]</ref> untersucht. Sie haben drei Daten-<lb/>strukturen miteinander verglichen: Hashtabellen, Binärbäume und Tries. Das Einfü-<lb/>gen einer Lösung und auch das Prüfen, ob eine Lösung schon enthalten ist, kann mit<lb/> einer Hashtabelle in O(l) (l entspricht der Länge des Strings) gemacht werden. Das<lb/> Finden einer neuen Lösung kann hingegen im schlimmsten Fall O(2<lb/> l ) Schritte benöti-<lb/>gen. Beim Binärbaum können alle drei Operationen in O(l * log 2 (n)) durchgeführt<lb/> werden. Der Nachteil dieser Datenstruktur ist, dass in jedem Knoten eine vollständige<lb/> Lösung gespeichert wird, was zu einem hohen Speicherverbrauch führt. Bei einem Trie<lb/> können alle Operationen in O(l) ausgeführt werden. Das führt zu dem Ergebnis, dass ein<lb/> Trie die geeignetste Datenstruktur, für die vorhin erwähnten benötigten Eigenschaften,<lb/> ist.<lb/></p>

			<figure type="table">Algorithmus 1 EA mit Lösungsarchiv<lb/> 1: generate random population pop and insert into archiv<lb/> 2: while termination condition not satisfied do<lb/> 3:<lb/> parent1 ← selection(pop)<lb/> 4:<lb/> parent2 ← selection(pop)<lb/> 5:<lb/> sol new ← recombination(parent1, parent2)<lb/> 6:<lb/> mutation(sol new )<lb/> 7:<lb/> lokaleImprovement(sol new )<lb/> 8:<lb/> 9:<lb/> if sol new included in archiv then<lb/> 10:<lb/> convert sol new to new solution<lb/> 11:<lb/> end if<lb/> 12:<lb/> insert sol new into archiv<lb/> 13:<lb/>replace one solution in pop with sol new<lb/> 14: end while<lb/>
			</figure>

			<head>1.4 Lösungsrepräsentationen<lb/></head>

			<p>In dieser Arbeit wurden zwei verschiedene Lösungsrepräsentationen verwendet: Die<lb/> Kodierung von Gosh <ref type="biblio">[2]</ref> und die von Pop <ref type="biblio">[11]</ref>. Beide Lösungsrepräsentationen wur-<lb/>den auch in den Arbeiten von Wolf <ref type="biblio">[15]</ref> und Sonnleitner <ref type="biblio">[13]</ref>, auf denen diese Arbeit<lb/> aufbaut, verwendet.<lb/></p>
			
			<figure>Abb. 2: Pop-Kodierung mit V 1 als Wurzelknoten<lb/></figure>

			<head>1.4.1 Gosh-Kodierung<lb/></head>

			<p>Bei der Gosh-Kodierung wird für jeden Cluster angegeben, welcher Knoten in diesem<lb/> Cluster ausgewählt wurde. Die kodierte Lösung besteht somit aus einem Vektor P =<lb/> {p 1 , p 2 , . . . , p m } wobei p i ∈ V für alle i = 1 . . . m. Um aus der kodierten Lösung den<lb/> Phänotypen und den dazugehörigen Lösungswert zu bekommen, kann dazu ein MST-<lb/>Algorithmus angewendet werden (z.B. Kruskal).<lb/></p>

			<head>1.4.2 Pop-Kodierung<lb/></head>

			<p>Bei der Pop-Kodierung wird gespeichert, welche Cluster miteinander verbunden sind.<lb/> Dazu wird ein globaler Graph definiert <ref type="biblio">[7]</ref>:G<lb/> G = (V<lb/> G , E<lb/> G ), wobei V<lb/> G den Clustern<lb/> des ursprünglichen Graphen G entsprechen und E<lb/> G den Kanten zwischen den Clustern,<lb/> d.h. E<lb/> G = V<lb/> G ×V<lb/> G . Auf diesen Graphen G<lb/> G kann nun ein Spannbaum S<lb/> G = (V<lb/> G , T<lb/> G )<lb/> gebildet werden, wobei T<lb/> G ⊆ E<lb/> G .<lb/></p>

			<p>Die Pop-Kodierung wird nun mithilfe der Predecessor-Darstellung gemacht. Dazu wird<lb/> ein Cluster als Wurzelcluster ausgewählt. In dem Spannbaum S<lb/> G gibt es nun für jeden<lb/> Cluster einen eindeutigen Pfad zum Wurzelcluster und somit auch einen eindeutigen<lb/> Vorgänger. Für die Lösungsrepräsentation wird in einem Vektor oder Array für jeden<lb/> Cluster (außer dem Wurzelcluster) der Vorgänger gespeichert. In <ref type="figure">Abb. 2</ref> ist ein Beispiel<lb/> dazu angegeben.<lb/></p>

			<p>Ein Problem dieser Kodierung ist, dass nicht jede Kodierung eine gültige GMST-Lösung<lb/> darstellt. Dieser Faktor muss bei den EA-Operationen berücksichtigt werden, damit<lb/> dadurch keine ungültigen Lösungen erstellt werden. Sonnleitner <ref type="biblio">[13]</ref> hat dazu in seiner<lb/> Arbeit einen Repair-Mechanismus entwickelt, mit dem ungültige Lösungen in gültige<lb/> umgewandelt werden können. Mittels dynamischer Programmierung kann dann aus der<lb/> kodierten Lösung die optimale Auswahl der Knoten innerhalb der Cluster erfolgen und<lb/> somit der Phänotyp und den dazugehörigen Lösungswert ermittelt werden.<lb/></p>

			<head>1.5 Branch and Bound<lb/></head>

			<p>Branch and Bound ist ein Verfahren, mit deren Hilfe man beweisbar optimale Lösungen<lb/> für kombinatorische Optimierungsprobleme finden kann. Das Verfahren beruht auf der<lb/> Idee der beschränkten Enumeration und basiert auf dem Divide &amp; Conquer Prinzip.<lb/> Branch and Bound-Algorithmen bestehen prinzipiell aus zwei Bereichen: Abgrenzung<lb/> (Bound) und Verzweigung (Branch).<lb/></p>

			<list>
				<item>• Verzweigung (Branch): Durch die Verzweigungsschritte wird das Problem in<lb/> mehrere Teilprobleme zerlegt, die dann leichter zu lösen sind. Durch wieder-<lb/>holte Anwendung des Verzweigungsschritts auf die Teilprobleme entsteht ein so-<lb/>genannter Entscheidungsbaum, der den Lösungsraum widerspiegelt.<lb/></item>

				<item>•Mit der Abgrenzung (Bound) wird versucht, Bereiche im Entscheidungsbaum<lb/> schon früh als schlecht zu erkennen und diese Bereiche somit nicht weiter zu<lb/> verfolgen, d.h. es werden schlechte Lösungen schon vorzeitig erkannt. Dazu<lb/> werden zwei Schranken definiert. Eine untere und eine obere Schranke. Bei<lb/> einem Minimierungsproblem entspricht die obere Schranke einer zulässigen Lö-<lb/>sung während die untere Schranke dem Weg von der Wurzel des Entscheidungs-<lb/>baums bis zum aktuellen Teilproblem entspricht. Ist nun die untere Schranke<lb/> schlechter (größer) als die obere Schranke, wird dieser Teil des Entscheidungs-<lb/>baums nicht weiter verfolgt. Falls sie kleiner als die obere Schranke ist, erfolgt<lb/> ein weiterer Verzweigungsschritt. Ist die untere Schranke eine zulässige Lösung<lb/> und ist sie besser als die aktuelle obere Schranke, so wird die untere Schranke die<lb/> neue obere Schranke.<lb/></item>
			</list>

			<p>Wie das Branch and Bound Verfahren in dieser Arbeit verwendet wurde, wird in Kapitel<lb/> 2 näher erläutert.<lb/></p>

			<head>1.6 Bisherige Ansätze<lb/></head>

			<p>Myung, Lee und Tcha <ref type="biblio">[8]</ref> haben in ihrer Arbeit das erste Mal das GMST-Problem for-<lb/>mal definiert und haben auch gezeigt dass das Problem NP-schwierig ist.<lb/></p>

			<p>Es gibt einige exakte Algorithmen, die aber nur Lösungen für relativ kleine Instanzen<lb/> liefern. In <ref type="biblio">[8]</ref> wurde ein exakter Algorithmus verwendet mit mehreren Integer Linear<lb/> Programming-Formulierungen und Branch and Bound Verfahren. Pop hat in <ref type="biblio">[11]</ref> eine<lb/> etwas effizientere Mixed Integer Linear Programming-Formulierung verwendet. Damit<lb/> konnten Instanzen mit bis zu 240 Knoten mit 30 Clustern oder 160 Knoten mit 40 Clus-<lb/>tern optimal gelöst werden. In <ref type="biblio">[1]</ref> wurde ein Branch and Cut Algorithmus verwendet.<lb/></p>

			<p>Um größere Instanzen zu lösen, müssen Metaheuristiken verwendet werden. Eine Meta-<lb/>heuristik ist ein Algorithmus bei dem nicht garantiert werden kann, dass eine optimale<lb/> Lösung gefunden wird. Man sucht vielmehr eine Lösung, die sich der optimalen Lösung<lb/> so gut wie möglich annähert. Eine Methaheuristik wird so definiert, dass sie von den<lb/> Optimierungsproblemen unabhängig sind. Eine auf ein bestimmtes Optimierungspro-<lb/>blem zugeschnittenes Verfahren wird dann Heuristik genannt.<lb/></p>

			<p>Für das GMST-Problem wurden auch einige Metaheuristiken angewandt. Gosh <ref type="biblio">[2]</ref> hat<lb/> in seiner Arbeit einige Metaheuristik-Ansätze umgesetzt, die auf Tabusuche, Variable<lb/> Neighborhood Descent und Variable Neighborhood Search basieren. Hu, Leitner und<lb/> Raidl <ref type="biblio">[3]</ref> haben in ihrer Arbeit einen Variable Neighborhood Search Ansatz entwick-<lb/>elt, der auf den Ansätzen von Gosh <ref type="biblio">[2]</ref> und Pop <ref type="biblio">[11]</ref> basieren. In <ref type="biblio">[4]</ref> haben sie diesen<lb/> Ansatz durch eine zusätzliche Nachbarschaft, die Teillösungen mittels Mixed Integer<lb/> Programming optimiert, erweitert und damit recht gute Ergebnisse erzielt.<lb/></p>

			<p>Wolf <ref type="biblio">[15]</ref> und Sonnleitner <ref type="biblio">[13]</ref> haben in ihren Arbeiten einen EA mit Lösungsarchiv<lb/> verwendet, wobei sie unterschiedliche Lösungsarchive angewendet haben. Wolf hat das<lb/> Archiv auf Basis der Gosh-Kodierung erzeugt, während Sonnleitner ein Archiv auf Ba-<lb/>sis der Pop-Kodierung verwendet hat. Außerdem hat Sonnleitner in seiner Arbeit noch<lb/> eine Variante entwickelt, die beide Archive gleichzeitig verwendet.<lb/> Wolf und Sonnleitner haben mit ihren Ansätzen beide Verbesserungen im Vergleich<lb/> zu einem normalen EA erreicht. Wobei Sonnleitner mit der Variante, in der er beide<lb/> Archive gleichzeitig verwendet, die besten Ergebnisse erzielt hat. Die Ergebnisse dieser<lb/> beiden Arbeiten wurden dann in der Arbeit <ref type="biblio">[5]</ref> zusammengefasst und veröffentlicht.<lb/></p>

			<p>Da in dieser Arbeit die beiden Archive von Wolf und Sonnleitner als Ausgangspunkt<lb/> genommen wurden und durch ein Bounding Strategie basierend auf einem Branch and<lb/> Bound Verfahren erweitert wurden, wird in den nächsten beiden Kapiteln auf die beiden<lb/> Ansätze nochmal genauer eingegangen.<lb/></p>

			<head>1.6.1 EA mit Gosh-Lösungsarchiv<lb/></head>

			<p>Wie vorher schon erwähnt, hat Wolf <ref type="biblio">[15]</ref> in seiner Arbeit das Lösungsarchiv auf Basis<lb/> der Gosh-Kodierung aufgebaut. Bei der Gosh-Kodierung wird, wie in Kapitel 1.4.1 be-<lb/>reits beschrieben, eine Lösung durch einen Vektor repräsentiert, bei dem jedes Element<lb/> einem Cluster entspricht, in dem gespeichert ist, welcher Knoten im Cluster ausgewählt<lb/> wurde.<lb/></p>

			<figure>Abb. 3: Lösung &lt;321112&gt; im Gosh-Lösungsarchiv eingefügt<lb/></figure>

			<p>Das Gosh-Lösungsarchiv ist ein Trie, bei dem jede Ebene einem Cluster V i entspricht.<lb/> Jeder Trie-Knoten enthält d i Pointer, d.h. für jeden Knoten im Cluster gibt es einen<lb/> Pointer. Die Pointer können folgende Zustände annehmen:<lb/></p>

			<list>
				<item>• null: Dieser Pointerwert gibt an, dass hier noch keine Lösung eingefügt wurde.<lb/></item>

				<item>• complete (c): Dieser Wert tritt auf, wenn das Ende einer Lösung erreicht wurde<lb/> oder alle Lösungen in den darunter liegenden Subtrie bereits complete sind.<lb/></item>

				<item>•normaler Pointer: Pointer zum nächsten Trie-Knoten.<lb/></item>
			</list>

			<p><ref type="figure">Abb. 3</ref> zeigt ein Beispiel wie ein Lösungsarchiv nach dem Einfügen einer Lösung<lb/> aussieht. In diesem Beispiel sind zwei Lösungen in dem Archiv bereits enthalten. Die<lb/> Lösung &lt;321112&gt; wurde dem Archiv neu hinzugefügt. Wie in Kapitel 1.3 beschrieben<lb/> werden für ein Lösungsarchiv zwei Funktionen benötigt. Eine Konvertierungs-und eine<lb/> Einfüge-Methode.<lb/></p>

			<head>Einfügen einer Lösung<lb/></head>

			<p>Beim Einfügen einer Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer<lb/> des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung<lb/> entspricht. Ist der Pointer null, wird ein neuer Trie-Knoten erzeugt und der Pointer wird<lb/> auf diesen neuen Knoten gesetzt. Wenn er complete ist, wurde die Lösung früher schon<lb/> einmal eingefügt und es kann abgebrochen werden. In diesem Fall wird im nächst-<lb/>en Schritt die Konvertierungs-Methode aufgerufen. Bei einer erfolgreichen Einfüge-<lb/>Operation, wird im untersten Trie-Knoten der jeweilige Pointer complete gesetzt. Da-<lb/>nach wird untersucht, ob es entlang der Lösung Teilbäume im Archiv gibt, die voll-<lb/>ständig untersucht wurden. Dazu wird beginnend in der untersten Ebene geprüft, ob<lb/> alle Pointer im Trie-Knoten complete sind. Wenn das der Fall ist, kann der Trie-Knoten<lb/> gelöscht werden und der dazugehörige Pointer im Eltern-Knoten auf complete gesetzt<lb/> werden. Diese Überprüfung erfolgt, beginnend bei dem untersten Trie-Knoten bis zur<lb/> Wurzel, für alle Trie-Konten entlang der Lösung.<lb/></p>

			<head>Konvertieren einer Lösung<lb/></head>

			<p>Um aus einer Lösung im Trie eine neue Lösung zu generieren, werden zunächst jene<lb/> Trie-Knoten ermittelt, die für eine Änderung in Frage kommen. Das sind jene Trie-<lb/>Knoten entlang der Lösung im Archiv, die nicht in einem als complete markierten<lb/> Bereich liegen. Danach wird aus diesen Trie-Knoten einer zufällig ausgewählt, indem<lb/> dann die Änderungen gemacht werden sollen. In diesem Trie-Knoten wird nach einem<lb/> null-Pointer gesucht. Wenn ein solcher null-Pointer vorhanden ist, wird die Lösung<lb/> dementsprechend abgeändert. Gibt es keinen, geht man im Trie entlang der Lösung<lb/> zum nächsten Trie-Knoten und wiederholt die Suche. Ist der Pointer der Lösung aber<lb/> complete wird ein anderer Pointer ausgewählt und zu diesem Trie-Knoten weiter gegan-<lb/>gen.<lb/></p>

			<p>Die Frage welche Ebene im Archiv welchem Cluster zugeordnet wird, wurde in <ref type="biblio">[15]</ref><lb/> näher betrachtet. Wenn die Trie-Knoten der i-ten Ebene im Archiv dem Cluster V i zu-<lb/>geordnet werden, kommt es zu einem Problem. Es entsteht ein so genanntes Bias im<lb/> Trie, d.h. die Wahrscheinlichkeit einer Lösungsänderung in einem Cluster ist nicht für<lb/> alle Cluster gleich groß. Die Knoten in den unteren Ebenen des Archivs haben eine<lb/> größere Chance verändert zu werden. Um dieses Problem zu umgehen, hat Wolf <ref type="biblio">[15]</ref><lb/> in seiner Arbeit eine zufällige Zuteilung der Cluster zu den Trie-Knoten verwendet,<lb/> d.h. beim Erstellen eines neuen Trie-Knoten, wird diesem zufällig ein Cluster zugeord-<lb/>net. Das hat zur Folge, dass nicht mehr einige Cluster bei der Veränderung der Lösung<lb/> bevorzugt werden.<lb/></p>

			<head>1.6.2 EA mit Pop-Lösungsarchiv<lb/></head>

			<figure>Abb. 4: Lösung &lt;-65611&gt; im Pop-Lösungsarchiv eingefügt, V 1 ist Wurzelcluster<lb/></figure>

			<p>Wie vorher schon erwähnt, hat Sonnleitner <ref type="biblio">[13]</ref> in seiner Arbeit das Lösungsarchiv auf<lb/> Basis der Pop-Kodierung aufgebaut. Bei der Pop-Kodierung werden, wie in Kapitel<lb/> 1.4.2 bereits beschrieben, die globalen Kanten zwischen den Clustern berücksichtigt.<lb/> Dabei werden die Vorgänger der Cluster in dem Spannbaum des globalen Graphen, in<lb/> einem Vektor gespeichert.<lb/> Das Pop-Lösungsarchiv ist ein Trie, der aus m − 1 Ebenen besteht, wobei jede Trie-<lb/>Ebene für ein Cluster steht. Außer für den Wurzelknoten, da dieser keinen Vorgänger<lb/> hat. In jedem Trie Knoten gibt es m − 1 Pointer, da ein Cluster in einem Baum nicht<lb/> sein eigener Vorgänger sein kann. In <ref type="figure">Abb. 4</ref> ist ein Beispiel zu sehen, wie eine Lösung<lb/> in einem Pop-Lösungsarchiv gespeichert wird. In diesem Beispiel sind zwei Lösungen<lb/> in dem Archiv schon enthalten. Die Lösung &lt;-65611&gt; wurde dem Archiv neu hinzuge-<lb/>fügt. Da in dieser Kodierung auch Lösungen dargestellt werden können, die keinen<lb/> Baum darstellen, gibt es in dem Pop-Lösungsarchiv, anders als im Gosh-Archiv, noch<lb/> einen zusätzlichen Pointerzustand, der eine ungültige Lösung markiert.<lb/> Die Pointer können daher folgende Zustände annehmen:<lb/></p>

			<list>

				<item>• null: Dieser Pointerwert gibt an, dass hier noch keine Lösung eingefügt wurde.<lb/></item>

				<item>• complete (c): Dieser Wert tritt auf, wenn das Ende einer Lösung erreicht wurde<lb/> oder alle Lösungen in dem darunter liegenden Subtrie bereits complete sind.<lb/></item>

				<item>• forbidden (f): Dieser Wert gibt an, dass diese Kodierung zu einer ungültigen Lö-<lb/>sung führt, d.h. zu keinem Baum.<lb/></item>

				<item>•normaler Pointer: Pointer zum nächsten Trie-Knoten.<lb/></item>

			</list>

			<head>Einfüge-und Konvertierungs-Funktionen<lb/></head>

			<p>Die Einfüge-Funktion läuft im Prinzip genauso ab wie im Gosh-Lösungsarchiv. Der<lb/> einzige Unterschied ist, dass beim Einfügen von neuen Trie-Knoten in den Trie die ver-<lb/>botenen Felder im Trie berechnet werden. Dazu werden in dem aktuellen Trie-Knoten<lb/> alle Cluster mit einem kleineren Index als dem aktuellen Cluster geprüft. Bei diesen<lb/> Clustern wird nun überprüft, ob diese Cluster den aktuellen Cluster als Vorgänger haben.<lb/> Ist das der Fall so kann dieser als forbidden markiert werden. Danach wird rekursiv<lb/> überprüft, ob es bereits hinzugefügte Cluster gibt, dessen Vorgänger der nun verbotene<lb/> Cluster ist. Diese werden ebenfalls als forbidden markiert.<lb/></p>

			<p>Die Konvertierungs-Funktion arbeitet im Prinzip genauso wie im Gosh-Lösungsarchiv.<lb/> Der Unterschied ist, dass hier bei jeder neu generierten Lösung nochmal geprüft werden<lb/> muss, ob es einen Zyklus gibt und sie somit keine gültige Lösung ist. Das muss gemacht<lb/> werden, da in der Einfüge-Funktion nicht alle möglichen Zyklen markiert werden kön-<lb/>nen.<lb/></p>

			<head>KAPITEL 2<lb/></head>

			<head>Algorithmus<lb/></head>

			<p>Zur Implementierung des Algorithmus wird ein Steady State EA gemeinsam mit einem<lb/> Gosh-und einem Pop-Lösungsarchiv verwendet. Die beiden Archive wurden in den<lb/> Arbeiten von Wolf <ref type="biblio">[15]</ref> und Sonnleitner <ref type="biblio">[13]</ref> bereits implementiert. Diese Archive wer-<lb/>den als Ausgangsposition genommen und durch eine Bounding Strategie basierend auf<lb/> einem Branch and Bound Verfahren erweitert.<lb/></p>

			<p>Wie in Kapitel 1.5 bereits beschrieben, besteht das Branch and Bound Verfahren aus<lb/> zwei Schritten, dem Verzweigen (Branch) und dem Abgrenzen (Bound). Der Branch-<lb/>Schritt ergibt sich aus dem Lösungsarchiv. Das Archiv kann im Prinzip als Entschei-<lb/>dungsbaum angesehen werden. In jedem Trie Knoten wird für einen bestimmten Clus-<lb/>ter eine Entscheidung getroffen und somit entstehen dadurch die verschiedenen Teil-<lb/>probleme. Im Gosh-Archiv bestehen die Entscheidungen in den Trie-Knoten aus der<lb/> Auswahl eines Knoten innerhalb eines Clusters, während im Pop-Archiv entschieden<lb/> wird, welchen Vorgänger der Cluster in dem Spannbaum hat. Für den Bound-Schritt<lb/> muss eine untere und eine obere Schranke definiert werden. Als obere Schranke wird<lb/> immer die bisher beste Lösung, die vom Evolutionären Algorithmus gefunden wurde,<lb/> genommen. Die untere Schranke wird in den einzelnen Trie-Knoten berechnet. Wie die<lb/> Berechnung genau erfolgt, wird in den Kapiteln 2.1 und 2.2 erläutert. Falls hier eine<lb/> untere Schranke gefunden wird, die größer als die beste bisher gefundene Lösung ist,<lb/> kann dieser Teil des Lösungsarchivs als complete markiert werden. Im weiteren Verlauf<lb/> des Algorithmus werden diese Lösungen schon als besucht erkannt und somit im EA<lb/> nicht mehr berücksichtigt.<lb/></p>

			<p>Es gibt prinzipiell zwei Möglichkeiten wann eine Bound berechnet wird. Zum einen<lb/> beim Einfügen der Lösung im Lösungsarchiv und zum anderen beim Konvertieren einer<lb/> schon eingefügten Lösung zu einer neuen. In dieser Arbeit werden beide Varianten<lb/> untersucht und auch miteinander kombiniert.<lb/></p>

			<head>2.1 Boundberechnung im Gosh-Archiv<lb/></head>

			<p>Die Boundberechnung erfolgt immer für einen bestimmten Pointer in einem Trie-Knoten.<lb/> Bei der Gosh-Kodierung wird, wie in Kapitel 1.4.1 bereits erläutert, für jeden Cluster<lb/> gespeichert, welcher Knoten in dem Cluster ausgewählt wurde. Soll in einem bestimmt-<lb/>en Trie-Knoten die Bound berechnet werden, bedeutet das, dass für alle Cluster vom<lb/> aktuellen Trie-Knoten bis hin zur Wurzel schon eine Auswahl der Knoten in den Clus-<lb/>tern getroffen wurde. Für alle Cluster in den darunterliegenden Trie-Ebenen wurde noch<lb/> keine Auswahl getroffen.<lb/></p>

			<p>Es ergeben sich also zwei Arten von Clustern. V<lb/> 1 ist die Menge der Cluster für die<lb/> bereits eine Knotenauswahl getroffen wurde und V<lb/> 0 ist die Menge der Cluster für die<lb/> noch keine Auswahl getroffen wurde.<lb/></p>

			<p>Um in einem bestimmten Trie-Knoten eine Bound zu berechnen, wird zunächst der<lb/>Graph G<lb/> = (V<lb/> , E<lb/> ) definiert, wobei V<lb/> = V<lb/> 1 ∪ V<lb/> 0 .Die Menge E<lb/> setzt sich aus 3<lb/> verschiedenen Arten von Kanten zusammen:<lb/></p>

			<list>

				<item>• E<lb/> 11 = V<lb/> 1 × V<lb/> 1 sind die Kanten zwischen allen Paaren von Clustern, für die<lb/> bereits eine Auswahl getroffen wurde. Die Kantenkosten ergeben sich aus der<lb/> Distanz zwischen den ausgewählten Knoten der Cluster.<lb/></item>

				<item>• E<lb/> 10 = V<lb/> 1 × V<lb/> 0 sind die Kanten zwischen allen Paaren von Clustern, bei de-<lb/>nen schon eine Auswahl getroffen wurde und denen für die noch keine gemacht<lb/> wurde. Die Kantenkosten zwischen den Clustern V i ∈ V<lb/> 1 und V j ∈ V<lb/> 0 lauten<lb/> c(p i , V j ) = min{c(p i , p j )|p j ∈ V j }, wobei p i ∈ V i ist.<lb/></item>

				<item>• E<lb/> 00 = V<lb/> 0 × V<lb/> 0 sind die Kanten zwischen allen Paaren von Clustern, für die<lb/> noch keine Auswahl getroffen wurde. Die Kantenkosten zwischen den Clustern V i ∈ V<lb/> 0 und V j ∈ V<lb/> 0 lauten c(V i , V j ) = min{c(p i , p j )|p i ∈ V i , p j ∈ V j }.<lb/></item>
			</list>

			<p>Die Definition der Kantenmenge lautet also E<lb/> = E<lb/> 11 ∪ E<lb/> 10 ∪ E<lb/> 00 . Die Berechnung<lb/> der Kantenkosten wird in einem Preprocessing-Schritt durchgeführt, d.h. sie erfolgt<lb/> einmal zu Beginn des Algorithmus und ist somit für die Laufzeit des Algorithmus<lb/> nicht mehr relevant. Um die Bound zu berechnen, wird für den Graphen G<lb/> ein mi-<lb/>nimaler Spannbaum S<lb/> = (V<lb/> , T<lb/> ) ermittelt, wobei T<lb/> ⊆ E<lb/> . Die Bound entspricht<lb/> dabei den Kosten des Spannbaums T<lb/> , C(T<lb/> ) =<lb/> (u,v)∈T c(u, v). Die Berechnung<lb/> des Spannbaums erfolgt mit einem Kruskal Algorithmus mit Union-Find. Die Laufzeit<lb/> dieses Algorithmus wird durch das Sortieren der Kanten bestimmt. Da der Graph G<lb/> ein<lb/> vollständiger Graph ist, entspricht die Anzahl der Kanten |E| = m * (m − 1). Dadurch<lb/> ergibt sich eine Laufzeit von O(m<lb/> 2 log(m<lb/> 2 )) für die Berechnung der Bound.<lb/></p>

			<figure>Abb. 5: Boundberechnung im Cluster V 3 beim Einfügen der Lösung &lt;321112&gt;<lb/></figure>

			<p>In <ref type="figure">Abb. 5</ref> wird illustriert wie eine Boundberechnung im Gosh-Lösungsarchiv funk-<lb/>tioniert. In diesem Beispiel wird im Trie-Knoten des Cluster V 3 die Bound berechnet.<lb/> An dieser Position wurden die Cluster V 1 , V 2 und V 3 schon in den oberen Ebenen einge-<lb/>fügt und somit eine Knotenauswahl für die Cluster getroffen. In den darunter liegenden<lb/> Clustern (V 4 , V 5 und V 6 ) wurde noch keine Auswahl getroffen. Für die Boundberech-<lb/>nung bedeutet das, dass hier zwischen den Clustern V 1 , V 2 und V 3 als Kantenkosten<lb/> der Abstand der ausgewählten Knoten genommen wird. Zwischen dem Cluster V 3 und<lb/> V 4 wird als Kosten der Distanzen zwischen dem ausgewählten Knoten 1 (V 3 ) und dem<lb/> Knoten 3 (V 4 ) genommen, da dieser die geringste Distanz zum Knoten 1 (V 3 ) hat. Zwi-<lb/>schen den Clustern V 4 , V 5 und V 6 werden die minimalen Distanzen zwischen den Clus-<lb/>tern verwendet. D.h. zwischen Cluster V 6 und V 4 wird die Kante zwischen Knoten 2<lb/> (V 6 ) und Knoten 1 (V 4 ) genommen und zwischen V 5 und V 4 wird die Kante zwischen<lb/> Knoten 1 (V 5 ) und Knoten 4 (V 4 ) genommen.<lb/></p>

			<p>Ist die berechnete Bound schlechter als die beste bisher gefundene Lösung, kann der<lb/> Pointer 1 des Clusters V 3 als complete markiert werden. Das kann gemacht werden,<lb/> da zwischen den Clustern V 4 , V 5 und V 6 immer der minimale Abstand genommen<lb/> wurde. Wenn nun Knoten in den Clustern ausgewählt werden, bleiben die Kosten des<lb/> Spannbaums gleich oder werden größer aber sie werden sicher nicht kleiner. Das führt<lb/> dazu, dass alle Lösungen in diesem Subtrie mindestens so groß sind als die berechnete<lb/> Bound und somit in diesem Fall auch größer sind als die beste bisher gefundene Lösung.<lb/></p>

			<head>2.1.1 Einfüge-Methode<lb/></head>

			<p>Wie vorhin schon erwähnt, ist eine Möglichkeit, wann die Boundberechnung durchge-<lb/>führt werden kann, die Einfüge-Operation des Lösungsarchivs. Beim Einfügen einer<lb/> Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt,<lb/> der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Bei einer erfolg-<lb/>reichen Einfüge-Operation werden also m Trie-Knoten durchlaufen. Eine Möglichkeit<lb/> wäre, in jedem dieser m Trie-Knoten für den jeweiligen Pointer, der dem ausgewählten<lb/> Knoten dieses Clusters in der Lösung entspricht, die Bound zu berechnen.<lb/></p>

			<p>Das führt aber zu einem Problem. Die Berechnung der Bound hat eine Laufzeit von<lb/> O(m<lb/> 2 log(m<lb/> 2 )). Wenn in jedem Trieknoten die Bound berechnet wird, müsste die<lb/> Bound m-mal ermittelt werden. Das würde zu einer Laufzeit von O(m<lb/> 3 log(m<lb/> 2 ))<lb/> führen, was eine erhebliche Verschlechterung gegenüber der normalen Einfüge-Operation<lb/> ohne Boundberechnung, mit einer Laufzeit von O(m), wäre.<lb/></p>

			<p>Eine Möglichkeit dieses Problem abzuschwächen ist es, die Bound nicht in jedem der<lb/> m Trie-Knoten zu berechnen, sondern nur in einer bestimmten Auswahl von Knoten.<lb/> Dazu wurde der Parameter branch_and_bound_prob eingeführt, mit dem angegeben<lb/> werden kann, mit welcher Wahrscheinlichkeit eine Boundberechnung für einen Trie-<lb/>Knoten durchgeführt wird. Als ein guter Wert für diesen Parameter hat sich 0, 05 her-<lb/>ausgestellt. Das bedeutet, es wird für 5% der Trie-Knoten die Bound berechnet. Die<lb/> Auswahl erfolgt dabei zufällig.<lb/></p>

			<p>In <ref type="table">Algorithmus 2</ref> ist der Pseudocode für die Einfüge-Operation mit Boundberechnung<lb/> dargestellt. Diese beruht auf der Einfüge-Operation von Wolf <ref type="biblio">[15]</ref>, nur dass diese durch<lb/> die Bounding Strategie erweitert wurde. Zunächst wird der Vektor V<lb/> 0 , in der alle Clus-<lb/>ter gespeichert sind, die noch nicht in das Archiv eingefügt worden sind, initialisiert.<lb/> Ausgehend vom Wurzelknoten wird nun immer dem Pointer des Trie-Knoten gefolgt,<lb/> der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Der Cluster wird<lb/> dabei immer aus dem Vektor V<lb/> 0 entfernt und dem Vektor V<lb/> 1 hinzugefügt, indem alle<lb/> Cluster gespeichert sind die schon eingefügt worden sind. Diese beiden Vektoren wer-<lb/>den dann für die spätere Boundberechnung benötigt. Ist der Pointer gleich null, muss<lb/> ein neuer Trie-Knoten angelegt werden. Dazu wird zufällig ein Cluster aus dem Vektor<lb/> V<lb/> 0 ausgewählt. Danach wird, mithilfe des Parameters branch_and_bound_prob, er-<lb/>mittelt ob für diesen Trie-Knoten eine Bound berechnet werden soll. Wird eine Bound<lb/> berechnet und ist sie schlechter als die beste bisher gefundene Lösung, werden alle<lb/> Trie-Knoten in den darunterliegenden Sub-Trie gelöscht und der Pointer als complete<lb/> markiert. Anschließend wird die Einfüge-Operation abgebrochen und f alse als Rück-<lb/></p>

			<figure type="table">Algorithmus 2 GoshTrie insert with Bound<lb/> Eingabe: sol -solution to insert; best solution bestsol<lb/> Ausgabe: insertion successfull (true/false)<lb/> Variablen: m=number of clusters; root=root from archiv<lb/> 1: V<lb/> 0 ← list with all numbers from 0 to m − 1<lb/> 2: curr ← root<lb/> 3: for i = 0...m − 1 do<lb/> 4:<lb/> pos ← sol[curr.cluster]<lb/> 5:<lb/> move cluster curr from V<lb/> 0 to V<lb/> 1<lb/> 6:<lb/> if curr.next[pos] == complete then<lb/> 7:<lb/> return false<lb/> 8:<lb/> end if<lb/> 9:<lb/> if curr.next[pos] == null then<lb/> 10:<lb/> if i == m − 1 then<lb/> 11:<lb/> curr.next[pos] ← complete<lb/> 12:<lb/> end if<lb/> 13:<lb/> rand ← random cluster from V<lb/> 0<lb/> 14:<lb/> V<lb/> 0 ← list with all numbers from 0 to m − 1<lb/> 15:<lb/> curr.next[pos] ← new node with cluster rand<lb/> 16:<lb/> end if<lb/> 17:<lb/> random choice if bound has to be calculated<lb/> 18:<lb/> if bound has to be calculated then<lb/> 19:<lb/> if bestsol &lt; calculateBound(V<lb/> 1 , V<lb/> 0 ) then<lb/> 20:<lb/> delete curr.next[pos]<lb/> 21:<lb/> curr.next[pos] ← complete<lb/> 22:<lb/> return f alse<lb/> 23:<lb/> end if<lb/> 24:<lb/> end if<lb/> 25:<lb/> curr ← curr.next[pos]<lb/> 26: end for<lb/> 27: check if there are complete subtrees along sol<lb/> 28: return true<lb/></figure>

			<p>gabewert zurück gegeben.<lb/></p>

			<p>Das hat zur Folge, dass die Lösung so behandelt wird als wäre sie schon einmal einge-<lb/>fügt worden und es wird eine neue Lösung generiert. Wenn das Einfügen erfolgreich<lb/> war, wird von unten nach oben entlang von sol untersucht, ob bei einem Trie-Knoten<lb/> alle Pointer complete sind. Ist das der Fall kann dieser gelöscht werden und der Pointer<lb/> im Eltern Knoten auf complete gesetzt werden.<lb/></p>

			<head>2.1.2 Konvertierungs-Methode<lb/></head>

			<p>Die zweite Möglichkeit, wann Boundberechnungen durchgeführt werden können, ist bei<lb/> der Konvertierungs-Operation des Lösungsarchivs. Bei der Konvertierungs-Operation<lb/> wird aus einer im Archiv enthaltenen Lösung eine neue Lösung gemacht, die der alten<lb/> möglichst ähnlich ist. Die Boundberechnung erfolgt nach jeder Änderung, die in der<lb/> alten Lösung gemacht wird. Ist diese Bound besser als die beste bisher gefundene Lö-<lb/>sung, wird diese neue Lösung akzeptiert. Ist die Bound aber schlechter, so werden die<lb/> Änderungen wieder rückgängig gemacht, die Lösung im Archiv als complete markiert<lb/> und danach weiter nach einer anderen neuen Lösung gesucht.<lb/></p>

			<p>In <ref type="table">Algorithmus 3</ref> ist dargestellt wie die Konvertierung mit Berücksichtigung der Bounds<lb/> funktioniert. Zuerst wird ein zufälliger Trie-Knoten der Lösung sol ausgewählt. In Zeile<lb/> 5 wird dann geprüft, ob es einen null-Pointer in dem ausgewählten Trie-Knoten gibt.<lb/> Wenn es einen gibt, wird die Lösung geändert und überprüft ob die Bound der neuen<lb/> Lösung an dieser Position schlechter ist als die beste bisher gefunden Lösung. Wenn sie<lb/> besser ist, wird sie akzeptiert und es kann abgebrochen werden. Ist sie schlechter, wird<lb/> die Änderung wieder rückgängig gemacht und der Pointer als complete markiert. Die<lb/> Suche wird danach fortgesetzt. In den Zeilen 14-21 wird versucht, entlang der Lösung<lb/> im Archiv eine Ebene nach unten zu gehen. Dieser Schritt erfolgt nur, wenn der Pointer<lb/> nicht complete ist und die Bound besser ist als die beste Lösung. Wenn entlang von<lb/> sol nicht nach unten gegangen werden kann, wird in den Zeilen 22-31 versucht einen<lb/> anderen Pointer, der nicht complete ist, zu finden und an diesen eine Ebene nach unten<lb/> zu gehen. Hier erfolgt wieder eine Überprüfung der Bound. Der ausgewählte Pointer<lb/> wird nur weiter verfolgt, wenn die Bound besser ist als die beste Lösung.<lb/></p>

			<p>Es kann vorkommen, dass in einem Trie-Knoten kein Pointer vorhanden ist, der zu<lb/> einer guten Bound führt. Das hat zur Folge, dass alle Pointer als complete markiert<lb/> werden und somit nicht mehr weiter nach unten gegangen werden kann. Deshalb muss<lb/> bei jedem Schleifendurchlauf überprüft werden, ob es noch einen Pointer gibt, der<lb/> nicht complete ist. Wenn nicht, wird dieser Trie-Knoten gelöscht und der zugehörige<lb/> Pointer im Eltern-Knoten als complete markiert. Danach kann Abgebrochen werden<lb/> und f alse zurück gegeben werden. Die Konvertierungs-Methode wird danach nochmal<lb/> aufgerufen.<lb/></p>

			<p>Das kann zu einem Problem führen. Wenn die Ausgangslösung relativ schlecht ist, kann<lb/> die Suche nach einer neuen Lösung recht lange dauern. Tests haben gezeigt, dass dieser<lb/> Fall nicht sehr oft auftritt und in den meisten Fällen schon nach wenigen Versuchen eine<lb/> neue Lösung gefunden werden kann. In wenigen Fällen wurde aber lange nach einer<lb/> Lösung gesucht. Um dieses Problem zu umgehen, wurde ein Parameter num_conv<lb/> eingeführt, mit dem die Anzahl der Konvertierungsversuche begrenzt werden kann.<lb/></p>

			<figure type="table">Algorithmus 3 GoshTrie convert with Bound<lb/> Eingabe: sol -solution to convert, best solution bestsol<lb/> Ausgabe: convertion successfull (true/false)<lb/> 1: curr ← random Trie-node along sol<lb/> 2: add all clusters from root to curr to V<lb/> 1 and the other clusters to V<lb/> 0<lb/> 3: while curr! = null &amp;&amp; curr! = complete do<lb/> 4:<lb/> check if all pointers in curr are complete, so we can cancel<lb/> 5:<lb/> if curr has a null-pointer then<lb/> 6:<lb/> sol[curr.cluster] ← random null-pointer of curr<lb/> 7:<lb/> if bestsol &lt; calculateBound(V<lb/> 1 , V<lb/> 0 ) then<lb/> 8:<lb/> curr.next[sol[curr.cluster]] ← complete<lb/> 9:<lb/> undo changes of sol<lb/> 10:<lb/> else<lb/> 11:<lb/> return true<lb/> 12:<lb/> end if<lb/> 13:<lb/> end if<lb/> 14:<lb/> if curr.next[sol[curr.cluster]]! = complete] then<lb/> 15:<lb/> move curr.next[sol[curr.cluster]].cluster from V<lb/> 0 to V<lb/> 1<lb/> 16:<lb/> if bestsol &lt; calculateBound(V<lb/> 1 , V<lb/> 0 ) then<lb/> 17:<lb/> delete curr.next[sol[curr.cluster]]<lb/> 18:<lb/> curr.next[sol[curr.cluster]] ← complete<lb/> 19:<lb/> else<lb/> 20:<lb/> curr ← curr.next[sol[curr.cluster]]<lb/> 21:<lb/> end if<lb/> 22:<lb/> else<lb/> 23:<lb/> sol[curr.cluster] ← a random not-complete-pointer, of curr<lb/> 24:<lb/> move curr.next[sol[curr.cluster]].cluster from V<lb/> 0 to V<lb/> 1<lb/> 25:<lb/> if bestsol &lt; calculateBound(V<lb/> 1 , V<lb/> 0 ) then<lb/> 26:<lb/> delete curr.next[sol[curr.cluster]]<lb/> 27:<lb/> curr.next[sol[curr.cluster]] ← complete<lb/> 28:<lb/> undo changes of sol<lb/> 29:<lb/> else<lb/> 30:<lb/> curr ← curr.next[sol[cur.cluster]]<lb/> 31:<lb/> end if<lb/> 32:<lb/> end if<lb/> 33: end while<lb/> 34: return f alse<lb/></figure>

			<head>2.2 Boundberechnung im Pop-Archiv<lb/></head>

			<p>Die Boundberechnung erfolgt, genauso wie beim Gosh-Archiv auch, immer für einen<lb/> bestimmten Pointer in einem Trie-Knoten. Bei der Pop-Kodierung wird, wie in Kapi-<lb/>tel 1.4.2 erläutert, für jeden Cluster der Vorgänger des minimalen Spannbaums, der aus<lb/> den globalen Graphen G<lb/> G erzeugt wird, gespeichert. Wenn in einem bestimmten Trie-<lb/>Knoten die Bound berechnet werden soll, bedeutet das, dass für alle Cluster vom ak-<lb/>tuellen Trie-Knoten bis hin zur Wurzel der Vorgänger bereits ausgewählt wurde. Diese<lb/> Menge wird als V<lb/> 1 bezeichnet. Für alle Cluster in den darunterliegenden Trie-Ebenen<lb/> wurde noch keine Auswahl getroffen. Sie sind noch mit keinem Cluster verbunden.<lb/> Diese Menge wird als V<lb/> 0 bezeichnet.<lb/></p>

			<p>Dadurch ergibt sich ein Wald G<lb/> . In<ref type="figure">Abb. 6</ref> wird illustriert, wie so ein Wald aussehen<lb/> kann. Die Abbildung zeigt einen Graph G<lb/> bei einer Boundberechnung im Trie-Knoten<lb/> von Cluster 6.<lb/></p>

			<p>Die Berechnung der Bound erfolgt nun in mehreren Schritten. In <ref type="table">Algorithmus 4</ref> wird<lb/> in dem Pseudocode gezeigt, wie die Boundberechnung funktioniert. Zunächst wird ein<lb/> Vektor data erzeugt, indem am Ende der Funktion die ausgewählten Knoten in den<lb/> Clustern gespeichert werden. Die Elemente von data werden mit -1 initialisiert.<lb/> Danach wird mit den Methoden calcClusters und generateList durch dynamische<lb/> Programmierung für die einzelnen Bäume von G<lb/> ermittelt, welche Knoten innerhalb<lb/></p>

			<figure>Abb. 6: Boundberechnung im Cluster V 6<lb/></figure>

			<figure type="table">Algorithmus 4 calcBoundByDynProg<lb/> Eingabe: root-node cN r; solution sol; current level of the trie aktP os<lb/> Ausgabe: bound<lb/> Variablen: data = list of the selected nodes of the clusters<lb/> 1: init data with −1<lb/> 2: nextcN r ← cN r<lb/> 3: repeat<lb/> 4:<lb/> calcClusters (nextcN r, sol, data, aktP os)<lb/> 5:<lb/> generateList (nextcN r, data[nextcN r], sol, aktP os)<lb/> 6:<lb/> nextinnerN ode ← next cluster with data[nextinnerN ode] = −1 and<lb/> nextinnerN ode &lt;= aktP os<lb/> 7:<lb/> if it exists a nextinnerN ode then<lb/> 8:<lb/> nextcN r ← getRootNode(sol, nextinnerN ode, aktP os)<lb/> 9:<lb/> end if<lb/> 10: until it exists a nextinnerN ode<lb/> 11: bound ← calculateBound(sol, data, aktP os)<lb/> 12: return bound<lb/></figure>

			<p>der Cluster ausgewählt werden sollen. Die Knoten werden so ausgewählt, dass die<lb/> Kosten der daraus entstehenden Lösung minimal sind. Begonnen wird dabei mit dem<lb/> Baum der vom Wurzelknoten des Lösungsarchivs ausgeht. Danach wird geprüft, ob es<lb/> noch ein Cluster in C ∈ V<lb/> 1 gibt, für den noch kein Knoten ausgewählt wurde, d.h.<lb/> dessen Eintrag in data noch -1 ist. Falls es so einen Cluster gibt, wird für diesen Cluster<lb/> C der Wurzelknoten des Baums, in dem er sich in G<lb/> befindet, ermittelt. Von diesem<lb/> Wurzelknoten wird nun wieder mit calcClusters und generateList eine Auswahl der<lb/> Knoten für die Cluster des Baums getroffen. Das wird solange wiederholt bis für alle<lb/> Cluster in V<lb/> 1 eine Auswahl getroffen wurde.<lb/></p>

			<p>Danach wird mit der Methode calculateBound mit einem angepassten Kruskal Algo-<lb/>rithmus ein minimum Spanning-Tree ermittelt. Ähnlich wie bei der Boundberechnung<lb/> im Gosh-Archiv, werden im Pop-Archiv auch drei Arten von Kanten zur Berechnung<lb/> verwendet:<lb/></p>

			<list>

				<item>• E<lb/> 11 = V<lb/> 1 × V<lb/> 1 ist die Menge aller Kanten von G<lb/> . Die Kantenkosten ergeben<lb/> sich aus dem Abstand zwischen den ausgewählten Knoten der Cluster.<lb/></item>

				<item>• E<lb/> 10 = V<lb/> 1 × V<lb/> 0 sind die Kanten zwischen allen Paaren von Clustern, bei de-<lb/>nen schon eine Auswahl getroffen wurde und denen für die noch keine gemacht<lb/> wurde. Die Kantenkosten zwischen den Clustern V i ∈ V<lb/> 1 und V j ∈ V<lb/> 0 lauten<lb/> c(p i , V j ) = min{c(p i , p j )|p j ∈ V j }, wobei p i ∈ V i ist.<lb/></item>

				<item>• E<lb/> 00 = V<lb/> 0 × V<lb/> 0 sind die Kanten zwischen allen Paaren von Clustern, für die<lb/> noch keine Auswahl getroffen wurde. Die Kantenkosten zwischen den Clustern<lb/>V i ∈ V<lb/> 0 und V j ∈ V<lb/> 0 lauten c(V i , V j ) = min{c(p i , p j )|p i ∈ V i , p j ∈ V j }.<lb/></item>

			</list>

			<p>Im Kruskal-Algorithmus werden jetzt zunächst alle Kanten von E<lb/> 11 eingefügt. Danach<lb/> werden die restlichen Kanten E<lb/> 10 ∪ E<lb/> 00 , wie bei einem normalen Kruskal-Algorithmus,<lb/> in der Reifenfolge ihrer Kantenkosten hinzugefügt, sodass kein Zyklus entsteht.<lb/></p>

			<figure type="table">Algorithmus 5 calcClusters<lb/> Eingabe: root-node cN r; solution sol; data; current level of the trie aktP os<lb/> 1: for i=0. . . aktP os do<lb/> 2:<lb/> if sol[i]==cN r then<lb/> 3:<lb/> calcClusters (i, sol, data, aktP os)<lb/> 4:<lb/> end if<lb/> 5: end for<lb/> 6: calcClusterweights (cN r, sol, data)<lb/></figure>

			<p>Wie vorhin bereits erwähnt, wird mit den Methoden calcClusters und generateList<lb/> die bestmögliche Auswahl von Knoten innerhalb der Cluster getroffen.<lb/> Zunächst wird mit calcClusters (<ref type="table">Algorithmus 5</ref>) für jeden Knoten der zu untersuchen-<lb/>den Cluster die Kosten berechnet, die entstehen wenn dieser Knoten ausgewählt wird.<lb/> Dazu wird calcClusters rekursiv aufgerufen, um, angefangen bei den Clustern in der<lb/> untersten Ebene, die Kosten für die Knoten zu berechnen.<lb/></p>

			<p>Die Kosten werden in der Methode calcClusterweights (<ref type="table">Algorithmus 6</ref>) berechnet.<lb/> Dazu wird für jeden Knoten p i ∈ C cur des jeweiligen Clusters C cur ∈ V<lb/> 1 die mini-<lb/>malen Kosten berechnet, die entstehen würden, wenn dieser ausgewählt werden würde.<lb/> Das geschieht, indem für alle Nachfolgecluster C suc ∈ V<lb/> 1 ein Knoten p j ∈ C suc<lb/> ausgewählt wird. Der Knoten p j wird dabei so gewählt, dass die Summe der Kosten<lb/> von p j und die Distanz von p i zu p j minimal ist. Die Kosten des Knoten sind also<lb/>C(p i ) =<lb/> p j ∈Psuc (C(p j ) + dist(p i , p j )), wobei P suc die Menge der minimalen Knoten<lb/> der Nachfolgecluster von C cur ist. In der Datenstruktur nodes werden für alle Knoten<lb/> deren Kosten C(p i ) gespeichert und berechnet und auch alle Knoten der Menge P suc<lb/> gespeichert. Diese Datenstruktur wird für die spätere Auswahl der Knoten in den Clus-<lb/>tern benötigt.<lb/></p>

			<p>Mit der Methode generateList (<ref type="table">Algorithmus 7</ref>) werden nun die ausgewählten Knoten<lb/> innerhalb der Cluster ermittelt. Dazu wird beginnend beim Wurzelcluster der Knoten<lb/> mit den geringsten Kosten in data gespeichert. Dazu wird die Datenstruktur nodes ver-<lb/>wendet, in der für jeden Knoten die günstigsten Nachfolgeknoten gespeichert sind.<lb/></p>

			<figure type="table">Algorithmus 6 calcClusterweights<lb/>Eingabe: current cluster cN r; solution sol; data<lb/> Variablen: minW eight=current minimal weight of the cluster<lb/>1: childCl ← all cluster which predecessor is cN r in sol<lb/> 2: for all nodes parentN ode in cluster cN r do<lb/> 3:<lb/> for all child in childCl do<lb/> 4:<lb/>for all nodes childN ode in cluster child do<lb/>5:<lb/> value= nodes[childN ode].weight + distance(parentN ode, childN ode)<lb/> 6:<lb/> if value &lt; minV alue then<lb/> 7:<lb/> minV alue=value<lb/> 8:<lb/> minChildN odeN r=childN ode<lb/> 9:<lb/> end if<lb/> 10:<lb/> end for<lb/> 11:<lb/> nodes[parentN ode].addF olower(child, minChildN odeN r, minV alue)<lb/> 12:<lb/> end for<lb/> 13:<lb/> if nodes[parentN ode].weight &lt; minWeight then<lb/> 14:<lb/> minW eight = nodes[parentN ode].weight<lb/> 15:<lb/> data[cN r] = parentN ode<lb/> 16:<lb/> end if<lb/> 17: end for<lb/></figure>

			<figure type="table">Algorithmus 7 generateList<lb/> Eingabe: current cluster cN r; node -selected node of cluster cN r node; solution sol;<lb/> data; current level of the trie aktP os<lb/> 1: data[cN r] = node<lb/> 2: for i=0 . . . aktP os do<lb/> 3:<lb/> if sol[i] == cN r then<lb/> 4:<lb/> generateList(i, nodes[node].getF ollower(i), data, sol, aktP os)<lb/> 5:<lb/> end if<lb/> 6: end for<lb/></figure>

			<p>Die Laufzeit der Boundberechnung wird durch die Berechnung der Kosten für die einzel-<lb/>nen Knoten bestimmt. Im schlimmsten Fall müssen für alle Knoten des Graphen die<lb/> Kosten berechnet werden. Deshalb kommt es zu einer Laufzeit von O(n<lb/> 2 ).<lb/></p>

			<head>2.2.1 Inkrementelle Boundberechnung<lb/></head>

			<p>In <ref type="biblio">[4]</ref> wurde eine Nachbarschaft verwendet, in der die neuen Lösungen inkrementell<lb/> berechnet wurden. Derselbe Ansatz soll auch in dieser Arbeit verwendet werden. Beim<lb/> Einfügen einer Lösung wird an verschiedenen Stellen entlang der Lösung im Trie die<lb/> Bound berechnet. Dabei werden aber für manche Teile der Lösung Berechnungen<lb/> mehrfach durchgeführt. Dasselbe gilt auch für das Berechnen von Bounds bei der Kon-<lb/>vertierung von Lösungen.<lb/></p>

			<p>Die Idee der inkrementellen Berechnung ist es, dass bei der ersten Berechnung der<lb/> Bound innerhalb einer Einfüge-bzw. Konvertierungs-Methode die Bound, wie vorhin<lb/> beschrieben, &quot;normal&quot; berechnet wird. Bei den nächsten Berechnungen der Bound<lb/> müssen nicht mehr für alle Teile des Baums die Kosten der Knoten berechnet werden.<lb/> Die Knotenkosten innerhalb eines Clusters V i können sich nur ändern, wenn V i einen<lb/> neuen Nachfolgecluster im Graphen G<lb/> bekommt oder die Kosten eines Nachfolgers<lb/> von V i sich geändert haben.<lb/></p>

			<p>Zur Umsetzung der inkrementellen Boundberechnung wurde ein Vektor valid verwen-<lb/>det, indem für jeden Cluster angegeben wird, ob sich die Knotenkosten in den Cluster<lb/> ändern. Die einzige Änderung die, gegenüber der &quot;normalen&quot; Boundberechnung zu<lb/> machen ist, ist in der Methode calcCluster vorzunehmen. In <ref type="table">Algorithmus 8</ref> ist zu se-<lb/>hen, wie die geänderte Methode aussieht. In der Methode wird der Vektor valid dazu<lb/> verwendet, um festzustellen, ob die Bound berechnet werden soll oder nicht.<lb/></p>

			<figure type="table">Algorithmus 8 calcClustersImprove<lb/> Eingabe: root-node cN r; solution sol; data; current level of the trie aktP os<lb/> 1: if !valid[cNr] then<lb/> 2:<lb/> for i=0. . . aktP os do<lb/> 3:<lb/> if sol[i]==cN r then<lb/> 4:<lb/> calcClusters (i, sol, data, aktP os)<lb/> 5:<lb/> end if<lb/> 6:<lb/> end for<lb/> 7:<lb/> calcCluster (cN r, sol, data)<lb/> 8: end if<lb/></figure>

			<head>2.2.2 Pop mit Nearest Neighbours Reduktion<lb/></head>

			<p>In <ref type="biblio">[10]</ref> wurde ein Ansatz verfolgt, indem für die Berechnung eines GTSP sogenannte<lb/> &quot;candidate lists&quot; verwendet wurden, um den Suchraum einzuschränken. Dabei wurden<lb/> für jeden Knoten die n nächsten Nachbarn in einer Liste gespeichert und nur diese als<lb/> mögliche Nachfolger in der Tour betrachtet. Der Ansatz wird auch in dieser Arbeit ver-<lb/>folgt. Dazu wird die Rekombinations-und Mutations-Methode des EAs entsprechend<lb/> angepasst. Außerdem wird in der Konvertierungs-Methode des Pop-Lösungsarchivs die<lb/> Nearest Neighbour Reduktion auch angewendet. Darauf wird später in Kapitel 2.2.4<lb/> genauer eingegangen werden.<lb/></p>

			<head>Rekombination<lb/></head>

			<p>Bei der Rekombinations-Methode wurde die in <ref type="biblio">[13]</ref> verwendete Methode als Grundlage<lb/> genommen und durch den Nearest Neighbour Ansatz ergänzt.<lb/> Die Rekombination wird dabei wie folgt durchgeführt: Für jedes Cluster C i wird über-<lb/>prüft, ob es in den beiden Lösungen den gleichen Vorgänger hat. Wenn das der Fall<lb/> ist, wird dieser Vorgänger in die neue Lösung übernommen. Hat der Cluster C i in den<lb/> beiden Lösungen unterschiedliche Vorgänger, gibt es drei Möglichkeiten:<lb/></p>

			<list>
				<item>• Ein Vorgänger C j ist in der Menge der Nearest Neighbours von C i und der andere<lb/> C k nicht: In diesem Fall wird C j in der neuen Lösung aufgenommen.<lb/></item>

				<item>• Beide Vorgänger sind in der Menge der Nearest Neighbours von C i : Hier wird<lb/> zufällig einer der beiden ausgewählt.<lb/></item>
			</list>

			<figure>Abb. 7: Rekombination von zwei Lösungen<lb/></figure>

			<list>
				<item>• Beide Vorgänger sind nicht in der Menge der Nearest Neighbours von C i : Hier<lb/> wird ebenfalls einer der beiden zufällig ausgewählt.<lb/></item>
			</list>

			<p>Beim Einfügen eines Clusters wird mittels Union Find überprüft, ob durch das Hinzufü-<lb/>gen des Clusters ein Zyklus entsteht. Ist das der Fall, so wird der Vorgänger der anderen<lb/> Lösung übernommen, d.h. der Cluster an dieser Stelle eingefügt. Führt das auch zu<lb/> einem Zyklus, wird dieser Cluster als nicht eingefügt markiert. Diese markierten Clus-<lb/>ter werden zum Schluss in den Baum hinzugefügt, indem zufällig ein Knoten aus der<lb/> Nearest Neighbours Liste des jeweiligen Clusters ausgewählt wird und er dann an dieser<lb/> Stelle eingefügt wird. Ist es nicht möglich den Cluster an einem Nearest Neighbour<lb/> anzuhängen, ohne einen Zyklus zu erzeugen, wird er zufällig an einer Stelle im Baum<lb/> angehängt. In <ref type="figure">Abb. 7</ref> ist ein Beispiel für eine solche Rekombination illustriert.<lb/></p>

			<head>Mutation<lb/></head>

			<p>Wie vorhin schon erwähnt, wurde in der Mutation-Methode der Nearest Neighbours<lb/> Ansatz auch umgesetzt. Dazu wurde die in <ref type="biblio">[13]</ref> verwendete Methode als Grundlage<lb/> genommen und durch den Nearest Neighbour Ansatz erweitert.<lb/></p>

			<p>In der Mutations-Methode wird an einer zufällig ausgewählten Stelle in der Lösung eine<lb/> Änderung vorgenommen. Der Ablauf der Mutations-Methode ist wie folgt: Zuerst wird<lb/> zufällig ein Cluster C i in der Lösung ausgewählt, dessen Vorgänger geändert werden<lb/> soll. Danach werden alle Nearest Neighbours ermittelt, deren direkten oder indirekten<lb/> Vorgänger nicht C i ist. Im nächsten Schritt wird aus dieser Liste zufällig ein neuer<lb/> Vorgänger ermittelt und in die neue Lösung gespeichert. Gibt es keinen solchen Nearest<lb/> Neighbour, werden mit Hilfe eines Tiefensuche-Algorithmus alle möglichen Cluster,<lb/> deren direkten oder indirekten Vorgänger nicht C i ist, ermittelt. Danach wird aus diesen<lb/> Clustern einer zufällig ausgewählt und als neuer Vorgänger für C i genommen. In <ref type="table">Algo-<lb/>rithmus 9</ref> wird gezeigt wie die Mutations-Methode funktioniert.<lb/></p>

			<figure type="table">Algorithmus 9 mutatePredecessor<lb/> Eingabe: Lösung sol<lb/> 1: mutate ← random cluster<lb/> 2: cand ← nearest neighbours from mutate where mutate is not the direct or indirect<lb/> predeccessor in sol<lb/> 3: if cand.size()! = 0 then<lb/> 4:<lb/> cand ←all cluster where mutate is not the direct or indirect predeccessor in sol<lb/> 5: end if<lb/> 6: pred new ← random element from cand<lb/> 7: sol[mutate] ← pred new<lb/></figure>

			<head>2.2.3 Einfüge-Methode<lb/></head>

			<p>Genau wie beim Gosh-Archiv wird auch beim Pop-Archiv die Bounding Strategie in<lb/> die Einfüge-Methode integriert. Bei der Pop-Einfüge-Methode wird, wie auch in Kapi-<lb/>tel 2.1.1, die Bound nicht in jedem Einfügeschritt berechnet, sondern nur für einen<lb/> Teil der Trie-Knoten der einzufügenden Lösung. Dazu wird wieder der Parameter<lb/> branch_and_bound_prob verwendet, der angibt mit welcher Wahrscheinlichkeit die<lb/> Bound für einen Trie-Knoten berechnet wird.<lb/></p>

			<figure type="table">Algorithmus 10 PopTrie insert with Bound<lb/> Eingabe: solution to insert sol; best solution bestsol<lb/> Ausgabe: insertion successfull (true/false)<lb/> Variablen: m=number of clusters; root=root from archiv<lb/> 1: curr ← root<lb/> 2: for i=0...m − 1 do<lb/> 3:<lb/> pos ← sol[curr.cluster]<lb/> 4:<lb/> if curr.next[pos] = complete then<lb/> 5:<lb/> return false<lb/> 6:<lb/> end if<lb/> 7:<lb/> if curr.next[pos] == null then<lb/> 8:<lb/> if i == m − 1 then<lb/> 9:<lb/> curr.next[pos] ← complete<lb/> 10:<lb/> end if<lb/> 11:<lb/> curr.next[pos] ← new trie-node<lb/> 12:<lb/> calculate forbidden pointers<lb/> 13:<lb/> end if<lb/> 14:<lb/> invalidate(i, sol)<lb/> 15:<lb/> if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, i) then<lb/> 16:<lb/> delete curr.next[pos]<lb/> 17:<lb/> curr.next[pos] ← complete<lb/> 18:<lb/> check if trie-nodes are complete<lb/> 19:<lb/> return false<lb/> 20:<lb/> end if<lb/> 21:<lb/> curr ← curr.next[pos]<lb/> 22: end for<lb/> 23: check if trie-nodes are complete<lb/> 24: return true<lb/></figure>

			<p>Der Ablauf der Insert-Methode wird in <ref type="table">Algorithmus 10</ref> gezeigt. Beim Einfügen einer<lb/> Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt,<lb/> der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Ist ein solcher<lb/> Pointer noch null, wird ein Trie-Knoten erzeugt und an dieser Stelle in den Trie einge-<lb/>fügt. Beim ersten Aufruf der Methode calcBoundByDynP rog wird die Bound mithilfe<lb/> der &quot;normalen&quot; dynamischen Programmierung ermittelt. Für alle weiteren Aufrufe<lb/> der Methode calcBoundByDynP rog innerhalb derselben Einfügeoperation wird die<lb/> inkrementelle Boundberechnung, die in Kapitel 2.2.1 beschrieben wird, verwendet.<lb/> Dazu müssen vorher alle Cluster, für die sich die Kosten der Knoten ändern, markiert<lb/> werden. Deshalb wird vor der Boundberechnung die Methode invalidate aufgerufen.<lb/> In dieser Methode werden alle Cluster, vom aktuellen Cluster bis hin zur Wurzel im<lb/> Spannbaum der Lösung, markiert.<lb/></p>

			<head>2.2.4 Konvertierungs-Methode<lb/></head>

			<p>In der Konvertierungs-Methode des Pop-Archivs wird die Bounding Strategie ebenfalls<lb/> angewendet. Die Konvertierungs-Methode mit Bounds funktioniert dabei ähnlich wie<lb/> die des Gosh-Archivs. Bei jeder Änderung der Lösung wird die Bound berechnet und<lb/> überprüft, ob diese besser als die beste bisher gefundene Lösung ist. Ist das nicht der<lb/> Fall, wird die Änderung rückgängig gemacht und eine andere Lösung gesucht. Zusät-<lb/>zlich zur Bounding Strategie wurde die Konvertierungs-Methode durch den Nearest<lb/> Neighbour Ansatz erweitert.<lb/></p>

			<p>In <ref type="table">Algorithmus 11</ref> wird der Ablauf der Konvertierungs-Methode gezeigt. Dabei wird<lb/> zunächst zufällig ein Trie-Knoten curr aus den möglichen Startknoten entlang der Lö-<lb/>sung ausgewählt. Im nächsten Schritt wird zuerst zufällig aus den Nearest Neighbours<lb/> von curr ein null-Pointer ausgewählt. Ist keiner vorhanden wird aus den restlichen<lb/> Pointern zufällig ein null-Pointer ausgewählt. Wurde ein null-Pointer gefunden, kann<lb/> eine neue Lösung generiert werden. Bei dieser neuen Lösung erfolgt dann eine Bound-<lb/>überprüfung. Die Boundberechnung wird mit Methode calcBoundByDynP rog durch-<lb/>geführt. Ist die Bound schlechter als die beste bisher gefundene Lösung, wird die Än-<lb/>derung der Lösung wieder rückgängig gemacht, der vorher ausgewählte Pointer auf<lb/> complete gesetzt und mit der Suche fortgesetzt. Ist die Bound nicht schlechter, kann<lb/> abgebrochen werden. Wurde kein null-Pointer gefunden, wird zunächst versucht, ent-<lb/>lang der Lösung im Archiv eine Ebene nach unten zu gehen. Hierbei wird wieder eine<lb/> Boundüberprüfung durchgeführt. Kann entlang der Lösung nicht weiter nach unten<lb/> gegangen werden, wird im aktuellen Trie-Knoten zufällig ein Pointer aus den Nearest<lb/> Neighbours von curr ausgewählt, der nicht complete ist. Wird so ein Pointer nicht<lb/> gefunden, wird aus den restlichen Pointern zufällig ein Pointer ausgewählt, der nicht<lb/> complete ist. Die Lösung wird dementsprechend geändert und es erfolgt wieder eine<lb/> Boundüberprüfung.<lb/></p>

			<p>Genauso wie bei der Insert-Methode in Kapitel 2.2.3, wird in dieser Methode beim er-<lb/>sten Aufruf von calcBoundByDynP rog die Bound mittels &quot;normalen&quot; dynamischen<lb/> Programmierung ermittelt. Bei allen weiteren Boundberechnungen innerhalb dersel-<lb/>ben Konvertierungsoperation, wird die inkrementelle dynamische Programmierungs-<lb/>Methode verwendet. Dazu wird vor jeder Boundberechnung die Methode invalidate<lb/> aufgerufen, die alle Cluster markiert, für die die Kosten neu berechnet werden müssen.<lb/></p>

			<figure type="table">Algorithmus 11 PopTrie convert with Bound<lb/> Eingabe: solution to convert sol; best solution bestsol<lb/> Ausgabe: convertion successfull (true/false)<lb/> Variablen: nn[i]... Nearest Neighbours of Cluster i<lb/> 1: curr ← random trie-node of the possible startpoints from sol<lb/> 2: while curr! = null &amp;&amp; curr! = complete do<lb/> 3:<lb/> p null ← random null-pointer from nn[curr], if none exist, random null-pointern<lb/> from all pointer in curr<lb/> 4:<lb/> if p null exists then<lb/> 5:<lb/> change solution and check if cycle exist<lb/> 6:<lb/> invalidate(curr.cluster, sol)<lb/> 7:<lb/> if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then<lb/> 8:<lb/> curr.next[sol[curr.cluster]] ← complete<lb/> 9:<lb/> undo changes of sol<lb/> 10:<lb/> else<lb/> 11:<lb/> return true<lb/> 12:<lb/> end if<lb/> 13:<lb/> else<lb/> 14:<lb/> if curr.next[sol[curr.cluster]]! = complete] then<lb/> 15:<lb/> invalidate(curr.cluster, sol)<lb/> 16:<lb/> if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then<lb/> 17:<lb/> delete curr.next[sol[curr.cluster]] and set it complete<lb/> 18:<lb/> else<lb/> 19:<lb/> curr ← curr.next[sol[curr.cluster]]<lb/> 20:<lb/> end if<lb/> 21:<lb/> else<lb/> 22:<lb/> sol[curr.cluster] ← random not-complete-pointer from nn[curr], if none<lb/> exist, random not-complete-pointer from all pointer in curr<lb/> 23:<lb/> invalidate(curr.cluster, sol)<lb/> 24:<lb/> if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then<lb/> 25:<lb/> delete curr.next[sol[curr.cluster]] and set it complete<lb/> 26:<lb/> undo changes of sol<lb/> 27:<lb/> else<lb/> 28:<lb/> curr ← curr.next[sol[cur.cluster]]<lb/> 29:<lb/> end if<lb/> 30:<lb/> end if<lb/> 31:<lb/> end if<lb/> 32: end while<lb/></figure>

			<head>KAPITEL 3<lb/></head>

			<head>Ergebnisse<lb/></head>

			<head>3.1 Vorgehensweise<lb/></head>

			<p>Die folgenden Tests wurden mit 14 TSPLib-Instanzen<lb/> 1 durchgeführt. Diese Instanzen<lb/> sind ursprünglich für das Traveling Salesman Problem erzeugt worden und wurden für<lb/> das GMST-Problem angepasst. Dazu wurden Cluster der Instanz hinzugefügt und die<lb/> einzelnen Knoten mittels geografischem Clustering zugeordnet. Die verwendeten In-<lb/>stanzen bestehen aus 150-442 Knoten und 30-89 Clustern. Im Schnitt hat also jedes<lb/> Cluster 5 Knoten. Die erweiterten TSPLib-Instanzen wurden auch von Wolf <ref type="biblio">[15]</ref> und<lb/> Sonnleitner <ref type="biblio">[13]</ref> verwendet, was einen Vergleich der Ergebnisse erleichtert.<lb/></p>

			<p>Da der EA ein randomisierter Algorithmus ist, wurden für alle Tests 30 Runs gemacht<lb/> und für die Auswertung der Mittelwert C avg(T ) = 1/n<lb/> n<lb/> i=1 C(T i ) und die Standard-<lb/>abweichung S =<lb/> 1/(n − 1)<lb/> n<lb/> i=1 (C(T i ) − C avg ) 2 genommen. Die Tests wurden auf<lb/> dem Cluster des Institut für Computergraphik und Algorithmen der TU-Wien durchge-<lb/>führt, welcher aus 14 Maschinen mit jeweils zwei QuadCore-CPUs und 24 GB Ar-<lb/>beitsspeicher besteht.<lb/></p>

			<p>Grundsätzlich wurden zwei Arten von Tests durchgeführt. Zum einen sind Testläufe<lb/> gemacht worden, bei denen der EA nach einer fixen Laufzeit terminiert und zum an-<lb/>deren Testläufe bei denen nach einer bestimmten Anzahl von Generationen der EA ter-<lb/>miniert. Letztere wurden unter anderem dazu verwendet, um den Speicherverbrauch<lb/> des Archivs genauer zu untersuchen.<lb/></p>

			<note>1 http://elib.zib.de/pub/Packages/mp-testdata/tsp/tsplib/tsp/index.html<lb/></note>

			<head>3.2 Tests mit fixer Laufzeit<lb/></head>

			<p>Die folgenden Tests wurden mit einer fixen Laufzeit durchgeführt. Die Daten der ver-<lb/>wendeten Testinstanzen und die Laufzeit werden in <ref type="table">Tabelle 1</ref> dargestellt.<lb/></p>

			<figure type="table">Tabelle 1: Testinstanzen und die verwendete Laufzeit<lb/> Instanz Knoten Cluster Laufzeit[s]<lb/> kroa150<lb/> 150<lb/> 30<lb/> 150<lb/> rat195<lb/> 195<lb/> 39<lb/> 150<lb/> d198<lb/> 198<lb/> 40<lb/> 150<lb/> krob200<lb/> 200<lb/> 40<lb/> 150<lb/> ts225<lb/> 225<lb/> 45<lb/> 200<lb/> pr226<lb/> 226<lb/> 46<lb/> 200<lb/> gil262<lb/> 262<lb/> 53<lb/> 300<lb/> pr264<lb/> 264<lb/> 54<lb/> 300<lb/> pr299<lb/> 299<lb/> 60<lb/> 300<lb/> lin318<lb/> 318<lb/> 64<lb/> 400<lb/> rd400<lb/> 400<lb/> 80<lb/> 450<lb/> fl417<lb/> 417<lb/> 84<lb/> 450<lb/> pr439<lb/> 439<lb/> 88<lb/> 600<lb/> pcb442<lb/> 442<lb/> 89<lb/> 600<lb/></figure>

			<head>3.2.1 Analyse der Cuts<lb/></head>

			<p>Zum Beginn der Tests sollte die Frage geklärt werden, ob und wie viele Teilbereiche des<lb/> Archivs abgeschnitten (als complete markiert) werden können. Außerdem sollte geklärt<lb/> werden, in welchen Bereichen des Archivs Teilbereiche abgeschnitten werden, also Cuts<lb/> gemacht werden. Cuts in den oberen Ebenen sind besser, da dadurch mehr Lösungen<lb/> im vorhinein ausgeschlossen werden können als bei Cuts in den unteren Ebenen. Dieser<lb/> Test wurde für beide Archive (Pop-und Gosh-Archiv) und für alle 14 Test-Instanzen<lb/> durchgeführt. Dabei wurde der EA nach einer konstanten Zeit terminiert.<lb/></p>

			<p>In <ref type="table">Tabelle 2</ref> werden die Ergebnisse dieses Tests dargestellt. In dieser Tabelle wird<lb/> gezeigt in welchem Teil des Archivs wie viele Cuts durchgeführt wurden. Die Spalte<lb/> 0 − 25% gibt an, wie viele Cuts in den oberen 25% der Ebenen im Archiv durchgeführt<lb/> wurden, in der Spalte 25 − 50% für die nächsten 25%, usw.<lb/></p>

			<figure type="table">Tabelle 2: Anzahl der Cuts in den unterschiedlichen Bereichen des Archivs<lb/>Gosh-Archiv<lb/> Pop-Archiv<lb/> Instanz 0-25%25-50%50-75%75-100% 0-25%25-50%50-75%75-100%<lb/> kroa150 0<lb/>0<lb/> 26<lb/> 11.081<lb/> 61<lb/> 857 10.721 23.394<lb/> rat195<lb/> 0<lb/> 0<lb/> 1<lb/> 5.982<lb/> 32<lb/> 635 3.376 14.438<lb/> d198<lb/> 0<lb/> 0<lb/> 3<lb/> 5.103<lb/> 410 5.500 11.913 14.468<lb/> krob200 0<lb/> 0<lb/> 1<lb/> 5.376<lb/> 19<lb/> 243 1.193 7.590<lb/> ts225<lb/> 0<lb/> 0<lb/> 0<lb/> 3.362<lb/> 0<lb/> 1<lb/> 99<lb/> 5.646<lb/> pr226<lb/> 0<lb/> 0<lb/> 3<lb/> 3.301<lb/> 721 6.687 12.744 15.731<lb/> gil262<lb/> 0<lb/> 0<lb/> 5<lb/> 6.937<lb/> 13<lb/> 295 3.067 9.529<lb/> pr264<lb/> 0<lb/> 0<lb/> 10<lb/> 5.473<lb/> 525 5.764 14.587 13.011<lb/> pr299<lb/> 0<lb/> 0<lb/> 1<lb/> 3.318<lb/> 45<lb/> 544 2.541 9.306<lb/> lin318<lb/> 0<lb/> 0<lb/> 6<lb/> 5.187<lb/> 332 3.119 12.809 16.113<lb/> rd400<lb/> 0<lb/> 0<lb/> 1<lb/> 3.475<lb/> 55<lb/> 637 4.898 9.744<lb/> fl417<lb/> 0<lb/> 0<lb/> 0<lb/> 1.835 2.741 14.811 10.400 7.802<lb/> pr439<lb/> 0<lb/> 0<lb/> 1<lb/> 3.141<lb/> 457 2.238 4.790 7.617<lb/> pcb442<lb/> 0<lb/> 0<lb/> 1<lb/> 3.349<lb/> 12<lb/> 360 2.510 6.367<lb/></figure>

			<p>Hier ist zu sehen, dass im Gosh-Archiv in den ersten 50% keine Bound gefunden wird,<lb/> die schlechter ist als die beste bisher gefunden Lösung, und somit auch kein Cut gemacht<lb/> werden kann. Da in den ersten 50% keine Cuts gemacht werden, ist es auch nicht nötig<lb/> die Bound in diesem Bereich zu berechnen, da das nur unnötig Laufzeit verbraucht. De-<lb/>shalb wurde der Parameter skip_bound eingeführt, mit dem angegeben werden kann, in<lb/> wie viel Prozent der oberen Ebenen die Bound nicht berechnet werden soll. Aufgrund<lb/> der erhaltenen Ergebnisse, wurde für die folgenden Tests der Parameter skip_bound für<lb/> das Gosh-Archiv auf 0, 5 gesetzt. Das bedeutet, dass für die oberen 50% des Archivs<lb/> wird die Bound nicht berechnet.<lb/></p>

			<p>Im Pop-Archiv sieht es hingegen anders aus. Hier kommt es auch in den oberen Ebenen<lb/> zu Cuts. Die Frage, die sich jetzt stellt, ist: Wieso werden im Pop-Archiv in den oberen<lb/> Ebenen Cuts gemacht aber im Gosh-Archiv nicht? Die Antwort auf die Frage findet<lb/> sich in den unterschiedlichen Kodierungen der Lösung, die in den Archiven verwendet<lb/> werden. Bei der Gosh-Kodierung wird für jeden Cluster gespeichert, welcher Knoten<lb/> in dem Cluster ausgewählt wird. Wird ein Eintrag für einen Cluster geändert, d.h. ein<lb/> anderer Knoten in dem Cluster ausgewählt, werden die Kosten der Gesamtlösung nicht<lb/> stark ansteigen, da die Knoten innerhalb eines Clusters relativ nahe zusammen liegen.<lb/> Bei der Pop-Kodierung wird für jeden Cluster der Vorgänger im Spannbaum des glob-<lb/>alen Graphen gespeichert. Kommt es hier zu einer Änderung für einen Cluster, können<lb/> die Kosten der Gesamtlösung stark ansteigen, falls die Cluster im Graphen weit au-<lb/>seinander liegen. D.h. wenn in den oberen Ebenen schon ein Vorgänger für einen Clus-<lb/>ter ausgewählt wird, der weiter entfernt liegt, kann das schon zu einer schlechten Bound<lb/> führen. Die unterschiedliche Kodierung ist auch der Grund, warum im Pop-Archiv mehr<lb/> Cuts gemacht werden als im Gosh-Archiv.<lb/></p>

			<head>3.2.2 Gosh-Archiv<lb/></head>

			<p>In den nächsten Tests wurde untersucht, wie sich die Bounding-Strategie auf das Gosh-<lb/>Archiv auswirkt. Dabei wurden drei Varianten betrachtet: Bounding-Strategie innerhalb<lb/> der Einfüge-Methode, Bounding-Strategie innerhalb der Konvertierungs-Methode und<lb/> die Variante, in der sie in beiden Methoden gleichzeitig verwendet wird. Dabei wurde<lb/> der Parameter skip_bound auf 0, 5 gesetzt. Für den Parameter branch_and_bound_prob<lb/> wurden Tests gemacht, bei denen der Wert dieses Parameters variiert wurde, um fest-<lb/>zustellen, welcher Wert die besten Ergebnisse liefert. Dabei hat sich heraus gestellt,<lb/> dass bei branch_and_bound_prob &gt; 0, 1 die Anzahl der erzeugten Generationen zu<lb/> stark abnimmt und somit schlechtere Ergebnisse geliefert werden. Auf die Ergebnisse<lb/> der Tests mit den Werten 0, 1 und 0, 05 wurde ein Wilcoxon-Rangsummenstatistik-<lb/>Test durchgeführt mit dem Resultat, dass beide Werte ähnliche Ergebnisse liefern, die<lb/> sich statistisch nicht signifikant unterscheiden. Da mit einem Wert von 0, 05 aber in<lb/> mehr Fällen bessere Resultate erzielt wurden, wurde für die folgenden Tests dieser Wert<lb/> genommen.<lb/></p>

			<p>Die Ergebnisse dieses Tests sind in <ref type="table">Tabelle 3</ref> zu sehen. In der Tabelle werden in der<lb/> Spalte T rie die Ergebnisse des &quot;normalen&quot; Gosh-Archivs ohne Bounding-Strategie,<lb/> unter T rie+insert−Bound die Variante mit Bounding-Strategie innerhalb der Einfüge-<lb/>Methode, im Bereich T rie + convert − Bound die Bounding-Strategie innerhalb der<lb/> Konvertierungs-Methode und unter T rie + ins&amp;conv − Bound bei der die Bounding-<lb/>Strategie in beiden Methoden gleichzeitig verwendet wird dargestellt. C avg entspricht<lb/> dem durchschnittlichen Lösungswert über alle Runs, darunter in Klammern steht die<lb/> Standardabweichung und Gen ist die durchschnittliche Anzahl der erzeugten Genera-<lb/>tionen.<lb/></p>

			<p>In den Ergebnissen ist zu sehen, dass alle drei Bounding Varianten gegenüber des &quot;nor-<lb/>malen&quot; Archivs bessere Ergebnisse liefern. Die Variante, in der die Bounding Strate-<lb/>gie in beiden Methoden verwendet wurde, liefert jedoch gegenüber der beiden anderen<lb/> Varianten schlechtere Ergebnisse. Dieses Resultat ist auf die geringere Anzahl von<lb/> erzeugten Generationen zurück zu führen. In einigen Instanzen wurden nur halb so<lb/> viele Generationen erzeugt als in den anderen Varianten.<lb/></p>

			<figure type="table">Tabelle 3: Vergleich der verschiedenen Bounding-Varianten im Gosh-Archiv<lb/>Trie<lb/> Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound<lb/> Instanz C avg (T ) Gen C avg (T ) Gen C avg (T )<lb/> Gen<lb/> C avg (T )<lb/> Gen<lb/>kroa150 9.822,0 60.747 9.822,0 52.511 9.819,9 29.509 9.819,6<lb/> 26.609<lb/> (21,4)<lb/> (12,7)<lb/> (17,7)<lb/> (17,8)<lb/> rat195 754,4 33.232 752,7 28.739 752,9<lb/> 17.602<lb/> 753,9<lb/> 14.481<lb/> (4,7)<lb/> (3,1)<lb/> (3,5)<lb/> (4,1)<lb/> d198 7.054,6 29.272 7.051,5 23,219 7.052,4 14.513 7.053,3<lb/> 12.707<lb/> (7,6)<lb/> (5,3)<lb/> (4,5)<lb/> (3,5)<lb/> krob200 11.248,831.790 11.246,1 22.863 11.245,3 16.887 11.260,6 14.727<lb/> (8,7)<lb/> (6,3)<lb/> (5,1)<lb/> (11,0)<lb/> ts225 62.306,332.698 62.275,4 26.467 62.286,5 20.472 62.292,1 18.346<lb/> (59,3)<lb/> (17,7)<lb/> (23,9)<lb/> (46,5)<lb/> pr226 55.515,031.541 55.515,0 25.289 55.515,0 12.098 55.515,0 10.576<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262 944,5 37.349 942,7 22.549 944,1<lb/> 19.123<lb/> 942,8<lb/> 15.878<lb/> (3,8)<lb/> (2,2)<lb/> (4,3)<lb/> (2,7)<lb/> pr264 21.895,133.368 21.891,1 21.467 21.890,1 16.071 21.890,6 11.679<lb/> (11,7)<lb/> (6,6)<lb/> (6,0)<lb/> (8,4)<lb/> pr299 20.354,326.404 20.339,7 15.985 20.346,2 13.081 20.341,0 11.389<lb/> (41,0)<lb/> (21,6)<lb/> (30,0)<lb/> (25,4)<lb/> lin318 18.540,527.309 18.535,1 21.289 18.532,4 13.220 18.528,0 10.738<lb/> (25,4)<lb/> (21,2)<lb/> (16,3)<lb/> (15,1)<lb/> rd400 5.950,6 21.185 5.945,4 14.815 5.947,6 9.260<lb/> 5.945,6<lb/> 8.261<lb/> (13,9)<lb/> (10,8)<lb/> (13,4)<lb/> (11,5)<lb/> fl417 7.982,0 22.146 7.982,0 15.208 7.982,0 6.324<lb/> 7.982,0<lb/> 5.457<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.873,917.653 51.828,2 7.855 51.827,0 10.339 51.826,3<lb/> 8.651<lb/> (54,5)<lb/> (35,5)<lb/> (35,7)<lb/> (26,7)<lb/> pcb442 19.667,218.106 19.657,4 7.576 19.648,9 10.707 19.654,5<lb/> 8.707<lb/> (38,0)<lb/> (40,3)<lb/> (27,3)<lb/> (34,3)<lb/></figure>

			<head>3.2.3 Nearest Neighbours<lb/></head>

			<p>Als nächstes wurde versucht herauszufinden, wie sich der Nearest-Neighbours-Ansatz,<lb/> der in Kapitel 2.2.2 erläutert wurde, auf den Evolutionären Algorithmus auswirkt. Bei<lb/> diesen Tests wurde der EA ohne Archiv verwendet. Dabei wurde der EA einmal mit und<lb/> einmal ohne dem Nearest-Neighbours-Ansatz verwendet und miteinander verglichen.<lb/> Bei diesem Test wurde der Parameter num_nearest_neighbour, der angibt, wie viele<lb/> Nachbarn in der Nearest-Neighbour-List eines Clusters enthalten sind, auf 5 gesetzt.<lb/> D.h. es werden für jeden Cluster die 5 nächsten Nachbarn bevorzugt. In <ref type="table">Tabelle 4</ref> sind<lb/> die Ergebnisse dieses Tests dargestellt. Hier ist zu sehen, dass der EA mit dem Nearest-<lb/>Neighbours-Ansatz für alle Instanzen eine Verbesserung liefert. Für die nachfolgenden<lb/> Tests wurde daher der Nearest-Neighbours-Ansatz auch verwendet.<lb/></p>

			<figure type="table">Tabelle 4: Vergleich von &quot;normalen&quot; EA mit einem EA mit Nearest Neighbours<lb/> EA<lb/> EA+NN<lb/> Instanz<lb/> C avg (T )<lb/> Gen<lb/> C avg (T )<lb/> Gen<lb/> kroa150<lb/> 9.831,8 302.576 9.831,5 303.589<lb/> (30,9)<lb/> (30,3)<lb/> rat195<lb/> 761,1<lb/> 199.953<lb/> 760,3<lb/> 199.391<lb/> (6,3)<lb/> (5,8)<lb/> d198<lb/> 7.068,7 183.405 7.057,3 180.270<lb/> (10,9)<lb/> (14,1)<lb/> krob200 11.291,4 185.572 11.277,6 185.052<lb/> (45,3)<lb/> (36,2)<lb/> ts225<lb/> 62.565,7 213.360 62.456,7 213.926<lb/> (131,1)<lb/> (152,7)<lb/> pr226<lb/> 55.515,0 199.954 55.515,0 200.307<lb/> (0,0)<lb/> (0,0)<lb/> gil262<lb/> 949,8<lb/> 244.354<lb/> 946,8<lb/> 243.635<lb/> (5,6)<lb/> (5,1)<lb/> pr264<lb/> 21.950,9 229.337 21.936,9 227.352<lb/> (29,9)<lb/> (32,2)<lb/> pr299<lb/> 20.411,4 187.223 20.369,1 185.952<lb/> (55,6)<lb/> (59,7)<lb/> lin318<lb/> 18.553,7 223.100 18.550,4 221.801<lb/> (33,9)<lb/> (30,3)<lb/> rd400<lb/> 5.993,6 166.799 5.978,6 165.978<lb/> (33,0)<lb/> (32,6)<lb/> fl417<lb/> 7.996,0 148.236 7.989,5 147.630<lb/> (6,9)<lb/> (8,2)<lb/> pr439<lb/> 52.045,4 178.455 52.016,5 177.110<lb/> (124,9)<lb/> (109,2)<lb/> pcb442 19.830,7 180.509 19.762,4 181.069<lb/> (113,7)<lb/> (113,6)<lb/></figure>

			<figure type="table">Tabelle 5: Vergleich der verschiedenen Bounding-Varianten im Pop-Archiv<lb/> Trie<lb/> Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound<lb/> Instanz C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| C avg (T )<lb/> |Gen|<lb/> kroa150 9.815,0 62.747 9.815,0 44.525 9.815,0 32.376 9.815,0<lb/> 24.844<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> rat195 752,5 36.732 751,5 25.765 751,9<lb/> 22.772<lb/> 752,2<lb/> 16.854<lb/> (3,0)<lb/> (2,0)<lb/> (2,5)<lb/> (2,7)<lb/> d198 7.046,1 30.787 7.044,0 20.328 7044,0 14.011 7.044,3<lb/> 10.249<lb/> (3,9)<lb/> (0,0)<lb/> (0,0)<lb/> (1,6)<lb/> krob200 11.245,3 34.399 11.244,0 24.306 11.244,0 21.614 11.246,0 17.198<lb/> (5,1)<lb/> (0,0)<lb/> (0,0)<lb/> (6,1)<lb/> ts225 62.268,7 38.580 62.268,2 28.141 62.268,5 29.270 62.268,5 22.654<lb/> (0,5)<lb/> (0,4)<lb/> (0,5)<lb/> (0,5)<lb/> pr226 55.515,033.056 55.515,0 19.713 55.515,0 17.736 55.515,0 10.571<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262 942,4 38.873 942,0 25.842 942,3<lb/> 24.078<lb/> 942,7<lb/> 18.201<lb/> (2,0)<lb/> (0,0)<lb/> (2,0)<lb/> (2,7)<lb/> pr264 21.886,0 36.538 21.886,0 23.104 21.886,0 22.734 21.886,0 13.226<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr299 20.318,6 28.971 20.316,1 18.548 20.316,0 20.506 20.320,6 13.950<lb/> (14,2)<lb/> (0,5)<lb/> (0,0)<lb/> (17,5)<lb/> lin318 18.525,5 34.659 18.523,9 17.283 18.523,0 22.782 18.522,2 11.108<lb/> (15,0)<lb/> (9,4)<lb/> (14,3)<lb/> (10,5)<lb/> rd400 5.945,2 25.867 5.943,2 14.627 5.942,5 19.263 5.942,7<lb/> 10.666<lb/> (16,5)<lb/> (7,9)<lb/> (6,9)<lb/> (7,2)<lb/> fl417 7.982,0 23.200 7.982,0 8.683 7.982,0 13.515 7.982,0<lb/> 2.578<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.796,5 24.933 51.794,0 14.215 51.793,5 20.692 51.791,6<lb/> 9.734<lb/> (29,7)<lb/> (16,6)<lb/> (10,8)<lb/> (2,7)<lb/> pcb442 19.630,2 26.755 19634,4 15.859 19.627,7 22.892 19.627,4 13.407<lb/> (23,6)<lb/> (20,2)<lb/> (15,7)<lb/> (15,6)<lb/></figure>

			<head>3.2.4 Pop-Archiv<lb/></head>

			<p>In diesem Kapitel wurde der Vergleich der verschiedenen Bounding-Strategien auch für<lb/> das Pop-Archiv durchgeführt. In Kapitel 3.2.1 wurde in dem Test herausgefunden, dass<lb/> Cuts in allen Ebenen des Tries vorkommen können. Deshalb wurde für den Vergleich<lb/> der Bounding-Strategien der Parameter skip_bound hier nicht verwendet, d.h. die<lb/> Bound wurde in jeder Ebene berechnet. Für den Parameter branch_and_bound_prob<lb/> wurden für das Pop-Archiv, genau wie im Kapitel 3.2.2 für das Gosh-Archiv, Tests mit<lb/> unterschiedlichen Werten für diesen Parameter gemacht. Mit dem Resultat, dass auch<lb/> hier der Wert 0, 05 die besseren Ergebnisse liefert.<lb/></p>

			<p><ref type="table">Tabelle 5</ref> zeigt die Ergebnisse für diesen Test. Hier ist zu sehen, dass die Varianten mit<lb/> den Bounding-Strategien meistens besser sind als die Variante mit &quot;normalem&quot; Archiv.<lb/> Außer für die Instanzen kroa150, pr226, pr264 und f l417 für die auch mit dem Archiv<lb/> ohne Bounding-Strategie das Optimum erreicht wurde.<lb/></p>

			<head>3.2.5 Beide Archive<lb/></head>

			<p>In <ref type="biblio">[13]</ref> wurde eine Variante getestet, bei der beide Archive gleichzeitig verwendet wur-<lb/>den. In dieser Arbeit soll auch getestet werden, wie sich die Bounding-Strategie in den<lb/> verschiedenen Varianten auswirkt, wenn beide Archive gleichzeitig verwendet werden.<lb/> Der Parameter skip_bound wird auf 0, 5 gesetzt. Dieser hat aber nur Auswirkungen<lb/> auf das Gosh-Archiv, d.h. im Pop-Archiv werden in allen Ebenen Bounds berechnet.<lb/> Der Parameter branch_and_bound_prob wurde, genau wie bei den vorherigen beiden<lb/> Tests, auf 0, 05 gesetzt.<lb/></p>

			<p>In <ref type="table">Tabelle 6</ref> sind die Ergebnisse dieses Tests zu sehen. Dabei wurden wieder 4 Varianten<lb/> miteinander verglichen: &quot;normalen&quot; Gosh und Pop Archive ohne Bounding-Strategie<lb/> (T rie), die Variante mit Bounding-Strategie innerhalb der Einfüge-Methode (T rie +<lb/> insert−Bound), die Bounding-Strategie innerhalb der Konvertierungs-Methode (T rie+<lb/> convert−Bound) und die Bounding-Strategie in beiden Methoden gleichzeitig (T rie+<lb/> ins&amp;conv − Bound). Hier ist zu sehen, dass bessere Ergebnisse bei den Varianten mit<lb/> Bounding-Strategie erzielt werden, außer bei den Instanzen bei denen das Optimum<lb/> schon mit den &quot;normalen&quot; Archiven erreicht wird. Außerdem ist zu sehen, dass in der<lb/> Variante, in der in beiden Methoden die Bounding-Strategie verwendet wird, schlechtere<lb/> Ergebnisse erreicht werden, als in den Varianten, wo die Bounding-Strategie nur bei der<lb/> Einfüge-oder Konvertierungs-Methode verwendet wird. Das ist auf die geringere An-<lb/>zahl von Generationen zurück zu führen, die oft nur halb so groß ist als bei den beiden<lb/> anderen Varianten.<lb/></p>

			<figure type="table">Tabelle 6: Vergleich der verschiedenen Bounding-Varianten bei der Kombination von<lb/> Gosh-und Pop Archiv<lb/> Trie<lb/> Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound<lb/> Instanz C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| C avg (T )<lb/> |Gen|<lb/> kroa150 9.815,0 21.637 9.815,0 14.801 9.815,0 9.853<lb/> 9.815,0<lb/> 7.638<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> rat195 752,1 18.540 751,3 11.167 752,8<lb/> 9.476<lb/> 752,6<lb/> 5.372<lb/> (2,8)<lb/> (1,4)<lb/> (3,4)<lb/> (3,2)<lb/> d198 7.044,0 11.199 7.044,0 7.149 7.044,0 5.418<lb/> 7.044,0<lb/> 3.924<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> krob200 11.244,016.633 11.244,0 10.592 11.244,0 10.370 11.244,0<lb/> 7.531<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> ts225 62.268,517.676 62.268,3 11.333 62.268,3 13.357 62.268,3<lb/> 9.474<lb/> (0,5)<lb/> (0,5)<lb/> (0,5)<lb/> (0,5)<lb/> pr226 55.515,0 1.148 55.515,0 625 55.515,0<lb/> 416<lb/> 55.515,0<lb/> 323<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262 942,0 20.694 942,0 11.228 942,0<lb/> 11.494<lb/> 942,0<lb/> 8.025<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr264 21.886,016.198 21.886,0 9.744 21.886,0 9.458 21.886,0<lb/> 6.099<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr299 20.316,015.475 20.316,0 8.480 20.316,0 9.625 20.316,0<lb/> 6.671<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> lin318 18.522,916.954 18.515,9 8.576 18.517,7 8.670 18.519,5<lb/> 5.218<lb/> (9,2)<lb/> (12,4)<lb/> (8,7)<lb/> (8,3)<lb/> rd400 5.940,3 14.236 5.937,7 6.692 5.938,9 8.545<lb/> 5.939,9<lb/> 5.184<lb/> (6,4)<lb/> (5,8)<lb/> (7,6)<lb/> (5,6)<lb/> fl417 7.982,0 1.486 7.982,0 875<lb/> 7.982,0<lb/> 585<lb/> 7.982,0<lb/> 418<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.791,012.837 51.792,2 6.101 51.791,0 9.331 51.791,0<lb/> 4.716<lb/> (0,0)<lb/> (6,4)<lb/> (0,0)<lb/> (0,0)<lb/> pcb442 19.625,817.457 19.623,6 8.198 19.620,5 10.872 19.622,8<lb/> 6.961<lb/> (19,1)<lb/> (17,4)<lb/> (18,7)<lb/> (18,3)<lb/></figure>

			<head>3.3 Fixe Anzahl von Generationen<lb/></head>

			<p>In den bisherigen Tests ist zu sehen, dass durch die Verwendung der Bounding-Strategie<lb/> die Anzahl der erzeugten Generationen geringer sind. Dadurch ist ein Vergleich des<lb/> Speicherverbrauchs der beiden Varianten nicht möglich, da bei dem Archiv ohne Bound-<lb/>ing mehr Lösungen in das Archiv eingefügt werden als beim Archiv mit Bounding.<lb/> Um jetzt den Speicherverbrauch der unterschiedlichen Varianten miteinander zu ver-<lb/>gleichen, wird als Abbruchbedingung für den EA eine fixe Anzahl von Generationen<lb/> genommen. So werden bei allen Varianten gleich viele Generationen erzeugt.<lb/></p>

			<p>Für diese Tests wurde die Abbruchbedingung des EAs auf 10.000 Generationen gesetzt.<lb/> In den <ref type="table">Tabellen 7 und 8</ref> sind die Ergebnisse für diese Tests zu sehen. In der <ref type="table">Tabelle<lb/> 7</ref> wurde das Gosh-Archiv untersucht, während in <ref type="table">Tabelle 8</ref> die Ergebnisse für das<lb/> Pop-Archiv zu sehen sind. Es wurden jeweils das &quot;normale&quot; Archiv ohne Bounding-<lb/>Strategie, das mit Bounding-Strategie in der Einfüge-Methode und das mit Bounding-<lb/>Strategie in der Konvertierungs-Methode miteinander verglichen. Die Spalte C avg ent-<lb/>spricht dabei wieder dem Durchschnitt der Lösungswerte über alle Runs, unter diesem<lb/> Wert steht in Klammern die Standardabweichung, Zeit entspricht der durchschnittlich<lb/> benötigten Zeit und M em den benötigten Speicher für das Archiv.<lb/></p>

			<p>In diesen Ergebnissen ist zu sehen, dass die Varianten mit Bound immer mehr Spei-<lb/>cher benötigen als die ohne Bound. Das kommt zunächst überraschend, da man zuerst<lb/> annehmen würde, dass durch die Bounding-Strategie auch weniger Speicher verbraucht<lb/> würde. Der Grund für den erhöhten Speicherverbrauch bei der Einfüge-Methode ist<lb/> in <ref type="figure">Abb. 8</ref> zu sehen. In diesem Beispiel wird zunächst versucht, im Gosh-Archiv die<lb/> Lösung &lt;321112&gt; (in der Grafik rot dargestellt) einzufügen. In Knoten V 5 wird eine<lb/> Bound festgestellt, die schlechter ist als die beste bisher gefundene Lösung, und somit<lb/> der Pointer 1 als complete markiert. Danach wird die Einfügeoperation abgebrochen<lb/> und f alse zurück geben. Für den EA sieht es daher so aus, als wäre die Lösung im<lb/> Archiv schon enthalten. Im nächsten Schritt wird mit der Konvertierungsmethode eine<lb/> neue Lösung &lt;341112&gt; erzeugt. Diese wird nun erfolgreich in das Archiv eingefügt.<lb/> Würde die Bounding-Strategie nicht verwendet werden, wäre die Lösung &lt;321112&gt;<lb/> beim ersten Mal eingefügt worden. Da die Bounding-Strategie verwendet wurde, ist nun<lb/> die Lösung &lt;321112&gt; bis zum Knoten V 5 und die Lösung &lt;341112&gt; ganz eingefügt<lb/> worden. D.h. beim Erzeugen einer neuen Lösung für die neue Generation wurden die<lb/> drei Knoten V 3, V 4 und V 5 des ersten Einfügeversuchs zusätzlich eingefügt. Deshalb<lb/> kommt es bei der Verwendung der Bounding-Strategie zu einem höheren Speicherver-<lb/>brauch.<lb/></p>

			<p>Um zu belegen, dass das der Grund für den erhöhten Speicherverbrauch ist, wurden<lb/> weitere Tests durchgeführt. Bei diesen Tests wurden Lösungen, bei denen eine Bound<lb/></p>

			<figure>Abb. 8: Grund für erhöhten Speicherverbrauch<lb/></figure>

			<p>gefunden wurde, die schlechter ist als die beste bisher gefundene Lösung, trotzdem in<lb/> der neuen Generation akzeptiert. D.h. wenn beim Einfügen einer Lösung eine schlechte<lb/> Bound gefunden wird, wird der jeweilige Pointer als complete markiert und dann true<lb/> zurück gegeben. Das hat zur Folge, dass der EA die Lösung als neu akzeptiert.<lb/></p>

			<p>Die Ergebnisse dieser Variante werden in <ref type="table">Tabelle 9</ref> gezeigt. Hier ist zu sehen, dass<lb/> für die meisten Instanzen bei dieser Variante weniger Speicher für das Archiv gebraucht<lb/> wurde.<lb/></p>

			<p>Bei der Bounding-Strategie in der Konvertierungs-Methode ist der Grund für den er-<lb/>höhten Speicherverbrauch ähnlich wie bei der Einfüge-Methode. Wenn bei der Konver-<lb/>tierungs-Methode in einem zufällig ausgewählten Startknoten der Lösung keine null-<lb/>Pointer gefunden werden, wird versucht, entlang der Lösung im Trie eine Ebene nach<lb/> unten zu gehen. Wenn das nicht möglich ist, wird versucht bei einem anderen nicht<lb/> complete-Pointer eine Ebene nach unten zu gehen. Wenn jetzt aufgrund von Bounds,<lb/> die schlechter als die beste bisher gefunden Lösung sind, in diesem neuen Knoten alle<lb/> Pointer complete werden, wird die Konvertierung abgebrochen und an einer anderen<lb/> Stelle nochmal versucht. Da der Pointer der Lösung in dem Startknoten in diesem Fall<lb/> auf complete gesetzt wurde, wird beim nächsten Konvertierungsversuch der Startknoten<lb/> aus den darüber liegenden Ebenen ausgewählt. D.h. bei der Verwendung der Bounding-<lb/>Strategie ist die Wahrscheinlichkeit höher, dass in den oberen Ebenen die Konvertierung<lb/> durchgeführt wird. Das führt dazu, dass beim anschließenden Einfügen einer Lösung<lb/> der neu einzufügende Subtrie größer ist. Deshalb werden mehr Trie-Knoten mit der<lb/> Bounding-Strategie erzeugt und somit kommt es auch zu einem erhöhten Speicherver-<lb/>brauch.<lb/></p>

			<figure type="table">Tabelle 7: Vergleich von Gosh-Trie mit 10000 Generationen<lb/>Trie<lb/> Trie+insert-Bound<lb/> Trie+convert-Bound<lb/> Instanz C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B]<lb/>kroa150 9.828,8 23<lb/> 6,7<lb/> 9.819,3 36<lb/> 8,0<lb/> 9.823,1 33<lb/> 6,6<lb/> (27,5)<lb/> (11,4)<lb/> (17,8)<lb/> rat195 755,9<lb/> 39<lb/> 10,7<lb/> 758,3<lb/> 75<lb/> 12,5<lb/> 757,6<lb/> 52<lb/> 11,4<lb/> (5,2)<lb/> (5,6)<lb/> (5,0)<lb/> d198 7.061,7 49<lb/> 8,2<lb/> 7.062,9 82<lb/> 9,7<lb/> 7.063,3 76<lb/> 8,4<lb/> (9,5)<lb/> (9,0)<lb/> (8,4)<lb/> krob200 11.269,1 42<lb/> 10,0<lb/> 11.273,9 68<lb/> 11,6<lb/> 11.279,9 58<lb/> 10,3<lb/> (25,2)<lb/> (42,0)<lb/> (48,3)<lb/> ts225 62.422,1 49<lb/> 17,3<lb/> 62.406,5 73<lb/> 19,0<lb/> 62.404,7 65<lb/> 16,6<lb/> (106,2)<lb/> (92,5)<lb/> (101,6)<lb/> pr226 55.515,0 64<lb/> 6,8<lb/> 55.515,0 126<lb/> 7,7<lb/> 55.515,0 128<lb/> 6,7<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262 948,9<lb/> 74<lb/> 17,9<lb/> 947,5 123<lb/> 21,3<lb/> 948,4 95,6<lb/> 18,2<lb/> (5,1)<lb/> (4,7)<lb/> (4,3)<lb/> pr264 21.913,2 80<lb/> 15,1<lb/> 21.905,0 139<lb/> 17,8<lb/> 21.914,9 118<lb/> 15,3<lb/> (31,4)<lb/> (18,2)<lb/> (26,1)<lb/> pr299 20.402,5 101<lb/> 18,8<lb/> 20.398,5 174<lb/> 22,1<lb/> 20.370,9 144<lb/> 19,1<lb/> (55,4)<lb/> (45,7)<lb/> (39,3)<lb/> lin318 18.548,9 113<lb/> 17,8<lb/> 18.545,6 217<lb/> 22,1<lb/> 18.556,1 183<lb/> 17,7<lb/> (26,6)<lb/> (22,1)<lb/> (27,5)<lb/> rd400 5.977,7 168<lb/> 25,8<lb/> 5.974,1 318<lb/> 31,9<lb/> 5.981,9 263<lb/> 25,7<lb/> (22,3)<lb/> (25,9)<lb/> (21,0)<lb/> fl417 7.982,0 204<lb/> 18,1<lb/> 7.982,0 499<lb/> 20,5<lb/> 7.982,0 478<lb/> 18,3<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.954,4 243<lb/> 28,9<lb/> 51.949,2 466<lb/> 34,3<lb/> 51.947,1 365<lb/> 62,8<lb/> (54,3)<lb/> (50,3)<lb/> (64,4)<lb/> pcb442 19.829,7 217<lb/> 34,4<lb/> 19.791,0 406<lb/> 41,1<lb/> 19.837,9 309<lb/> 34,5<lb/> (105,0)<lb/> (75,2)<lb/> (109,1)<lb/></figure>

			<figure type="table">Tabelle 8: Vergleich von Pop-Trie mit 10000 Generationen<lb/>Trie<lb/> Trie+insert-Bound<lb/> Trie+convert-Bound<lb/> Instanz C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B]<lb/>kroa150 9.815,0 24<lb/> 28,9<lb/> 9.815,0 35<lb/> 42,3<lb/> 9.815,0 37<lb/> 32,8<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> rat195 751,6<lb/> 41<lb/> 55,4<lb/> 751,5<lb/> 64<lb/> 84,1<lb/> 752,1<lb/> 58<lb/> 59,5<lb/> (2,1)<lb/> (2,0)<lb/> (2,8)<lb/> d198 7.046,5 49<lb/> 49,0<lb/> 7.045,4 90<lb/> 95,9<lb/> 7.044,6 99<lb/> 54,1<lb/> (4,0)<lb/> (3,3)<lb/> (2,3)<lb/> krob200 11.246,1 44<lb/> 58,3<lb/> 11.246,3 66<lb/> 75,7<lb/> 11.244,7 55<lb/> 61,2<lb/> (6,2)<lb/> (6,4)<lb/> (3,7)<lb/> ts225 62.268,5 53<lb/> 84,7<lb/> 62.268,5 74<lb/> 96,9<lb/> 62.268,4 61<lb/> 85,3<lb/> (0,5)<lb/> (0,5)<lb/> (0,5)<lb/> pr226 55.515,0 61<lb/> 76,1<lb/> 55.515,0 140<lb/> 171,2<lb/> 55.515,0 100<lb/> 89,3<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262 942,4<lb/> 78<lb/> 111,4<lb/> 942,5 128<lb/> 158,3<lb/> 942,4<lb/> 93<lb/> 115,8<lb/> (2,0)<lb/> (2,3)<lb/> (2,0)<lb/> pr264 21.886,0 83<lb/> 108,5<lb/> 21.886,0 169<lb/> 210,9<lb/> 21.886,0 106<lb/> 115,9<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr299 20.325,3 105<lb/> 133,6<lb/> 20.318,6 202<lb/> 225,2<lb/> 20.317,7 129<lb/> 137,4<lb/> (19,5)<lb/> (9,3)<lb/> (7,8)<lb/> lin318 18.521,4 116<lb/> 163,5<lb/> 18.519,5 298<lb/> 384,1<lb/> 18.524,2 152<lb/> 174,2<lb/> (13,2)<lb/> (14,2)<lb/> (12,8)<lb/> rd400 5.943,0 178<lb/> 264,7<lb/> 5.942,8 502<lb/> 600,1<lb/> 5.944,7 212<lb/> 276,9<lb/> (9,7)<lb/> (7,1)<lb/> (7,8)<lb/> fl417 7.982,0 196<lb/> 265,0<lb/> 7.982,0 1.041<lb/> 845,7<lb/> 7.982,0 326<lb/> 302,5<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.792,3 248<lb/> 309,3<lb/> 51.793,0 687<lb/> 679,3<lb/> 51.791,1 267<lb/> 315,3<lb/> (6,7)<lb/> (8,0)<lb/> (0,3)<lb/> pcb442 19.628,9 229<lb/> 360,0<lb/> 19.628,1 527<lb/> 615,6<lb/> 19.633,6 244<lb/> 367,4<lb/> (20,5)<lb/> (19,1)<lb/> (21,4)<lb/></figure>

			<figure type="table">Tabelle 9: Vergleich von Pop-Tries mit 10000 Generationen ohne return<lb/> Trie<lb/> Trie+insert-Bound<lb/> Instanz<lb/> C avg (T ) Zeit [s] M em [M B] C avg (T ) Zeit [s] M em [M B]<lb/> kroa150<lb/> 9.815,0<lb/> 24<lb/> 28,9<lb/> 9.815,0<lb/> 36<lb/> 29,2<lb/> (0,0)<lb/> (0,0)<lb/> rat195<lb/> 751,6<lb/> 41<lb/> 55,4<lb/> 751,5<lb/> 61<lb/> 54,6<lb/> (2,1)<lb/> (2,0)<lb/> d198<lb/> 7.046,5<lb/> 49<lb/> 49,0<lb/> 7.045,6<lb/> 89<lb/> 44,4<lb/> (4,0)<lb/> (3,4)<lb/> krob200 11.246,1<lb/> 44<lb/> 58,3<lb/> 11.244,7<lb/> 62<lb/> 58,3<lb/> (6,2)<lb/> (3,7)<lb/> ts225<lb/> 62.268,5<lb/> 53<lb/> 84,7<lb/> 62.268,4<lb/> 71,9<lb/> 82,8<lb/> (0,5)<lb/> (0,5)<lb/> pr226<lb/> 55.515,0<lb/> 61<lb/> 76,1<lb/> 55.515,0<lb/> 106<lb/> 75,8<lb/> (0,0)<lb/> (0,0)<lb/> gil262<lb/> 942,4<lb/> 78<lb/> 111,4<lb/> 942,3<lb/> 111<lb/> 111,9<lb/> (2,0)<lb/> (2,0)<lb/> pr264<lb/> 21.886,0<lb/> 83<lb/> 108,5<lb/> 21.886,0<lb/> 121<lb/> 101,8<lb/> (0,0)<lb/> (0,0)<lb/> pr299<lb/> 20.325,3<lb/> 105<lb/> 133,6<lb/> 20.320,3<lb/> 158<lb/> 130,9<lb/> (19,5)<lb/> (13,0)<lb/> lin318<lb/> 18.521,4<lb/> 116<lb/> 163,5<lb/> 18.522,4<lb/> 183<lb/> 156,8<lb/> (13,2)<lb/> (11,2)<lb/> rd400<lb/> 5.943,0<lb/> 178<lb/> 264,7<lb/> 5.944,7<lb/> 292<lb/> 259,6<lb/> (9,7)<lb/> (7,7)<lb/> fl417<lb/> 7.982,0<lb/> 196<lb/> 265,0<lb/> 7.982,0<lb/> 384<lb/> 239,5<lb/> (0,0)<lb/> (0,0)<lb/> pr439<lb/> 51.792,3<lb/> 248<lb/> 309,3<lb/> 51.791,0 377,9<lb/> 299,2<lb/> (6,7)<lb/> (0,0)<lb/> pcb442 19.628,9<lb/> 229<lb/> 360,0<lb/> 19.630,5<lb/> 354<lb/> 355,2<lb/> (20,5)<lb/> (21,8)<lb/>
			</figure>

			<head>3.4 State of the Art<lb/></head>

			<p>In <ref type="table">Tabelle 10</ref> wurden die Ergebnisse dieser Arbeit mit den Ergebnissen anderer Arbeiten<lb/> verglichen, um zu sehen, wie der EA Ansatz mit Lösungsarchiv und Bounding-Strategie<lb/> im Vergleich abschneidet. Die Ergebnisse wurden aus der Arbeit <ref type="biblio">[5]</ref> übernommen. In<lb/> <ref type="table">Tabelle 10</ref> werden vier Verfahren miteinander verglichen: ein Tabu Search Verfahren<lb/> (TS) von <ref type="biblio">[2]</ref>, ein Variable Neighborhood Search Verfahren (VNS) von <ref type="biblio">[4]</ref>, ein Ver-<lb/>fahren basierend auf Dynamic Candidates Sets (DCS) von <ref type="biblio">[6]</ref> und einem EA mit einem<lb/> Archiv in Kombination mit einer Bounding-Strategie. Bei dem Verfahren mit Boundig-<lb/>Strategie wurden die Ergebnisse genommen, bei denen beide Archive kombiniert wur-<lb/>den und die Bound nur in der Konvertierungs-Methode verwendet wurde. Hier ist zu<lb/> sehen, dass das Verfahren mit Bounding-Strategie durchaus mit den anderen Verfahren<lb/> mithalten kann und in einigen Instanzen auch bessere Ergebnisse liefert.<lb/></p>

			<figure type="table">Tabelle 10: Vergleich mit anderen State of the Art Verfahren<lb/> TS<lb/> VNS<lb/> DCS<lb/> EA+Archiv+Bound<lb/> Instanz<lb/> C avg (T ) C avg (T ) C avg (T )<lb/> C avg (T )<lb/> kroa150<lb/> 9.815,0<lb/> 9.815,0<lb/> 9.815,0<lb/> 9.815,0<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> d198<lb/> 7.062,0<lb/> 7.044,0<lb/> 7.044,0<lb/> 7.044,0<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> krob200 11.245,0 11.244,0 11.244,0<lb/> 11.244,0<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> ts225<lb/> 62.366,0 62.268,5 62.268,3<lb/> 62.268,3<lb/> (0,5)<lb/> (0,5)<lb/> (0,5)<lb/> pr226<lb/> 55.515,0 55.515,0 55.515,0<lb/> 55.515,0<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262<lb/> 942,0<lb/> 942,3<lb/> 942,0<lb/> 942,0<lb/> (1,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr264<lb/> 21.886,0 21.886,5 21.886,0<lb/> 21.886,0<lb/> (1,8)<lb/> (0,0)<lb/> (0,0)<lb/> pr299<lb/> 20.339,0 20.322,6 20.317,4<lb/> 20.316,0<lb/> (14,7)<lb/> (1,5)<lb/> (0,0)<lb/> lin318<lb/> 18.521,0 18.506,8 18.513,6<lb/> 18.517,7<lb/> (11,6)<lb/> (7,8)<lb/> (8,7)<lb/> rd400<lb/> 5.943,0<lb/> 5.943,6<lb/> 5.941,5<lb/> 5.938,9<lb/> (9,7)<lb/> (9,9)<lb/> (7,6)<lb/> fl417<lb/> 7.990,0<lb/> 7.982,0<lb/> 7.982,7<lb/> 7.982,0<lb/> (0,0)<lb/> (0,5)<lb/> (0,0)<lb/> pr439<lb/> 51.852,0 51.847,9 51.833,8<lb/> 51.791,0<lb/> (40,9)<lb/> (36,0)<lb/> (0,0)<lb/> pcb442 19.621,0 19.702,8 19.662,5<lb/> 19.620,5<lb/> (52,1)<lb/> (39,8)<lb/> (18,7)<lb/></figure>

			<head>KAPITEL 4<lb/></head>

			<head>Zusammenfassung<lb/></head>

			<p>In dieser Arbeit wurde ein Evolutionärer Algorithmus mit zwei verschiedenen Varianten<lb/> von Lösungsarchiven (Gosh-Archiv und Pop-Archiv) durch eine Bounding-Strategie<lb/> basierend auf dem Branch and Bound Verfahren erweitert. Zusätzlich wurde auch ein<lb/> Nearest Neighbour Ansatz angewendet, bei dem beim Anhängen eines Clusters an den<lb/> Spannbaum die n nächsten Nachbarcluster bevorzugt werden.<lb/></p>

			<p>Bei der Bounding-Strategie werden in den einzelnen Trie-Knoten geeignete Bounds<lb/> berechnet, die eine Aussage darüber machen können, wie gut die Lösungen im darunter<lb/> liegenden Subtrie bestenfalls sein können. Mit diesen Bounds können viele Lösungen<lb/> von vornherein als schlecht markiert werden. Die Boundberechnung erfolgt in 3 ver-<lb/>schiedenen Varianten: Boundberechnung in der Einfüge-Methode des Archivs, in der<lb/> Konvertierungs-Methode und in beiden Methoden gleichzeitig.<lb/></p>

			<p>Diese Varianten wurden in den beiden Archiven getestet und verglichen. Im Gosh-<lb/>Archiv haben die Bounding Varianten in allen Instanzen bessere Ergebnisse erzielt, als<lb/> bei der &quot;normalen&quot; Variante. Die Variante, in der in beiden Methoden die Bounding-<lb/>Strategie verwendet wird, hat jedoch schlechtere Ergebnisse gebracht als in den anderen<lb/> beiden Bounding-Varianten. Das ist auf die geringere Anzahl von erzeugten Gener-<lb/>ationen zurück zu führen. Im Pop-Archiv waren die Ergebnisse der Bounding Vari-<lb/>anten ebenfalls besser als die der &quot;normalen&quot; Variante. Bei der Variante, in der beide<lb/> Archive gemeinsam verwendet wurden, haben die Bounding-Varianten ebenfalls eine<lb/> Verbesserung erzielt. Beim Vergleich zwischen den Archiven kann man sagen, dass<lb/> die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der<lb/> beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen bei-<lb/>den Varianten.<lb/></p>

			<p>Die Tests haben ebenfalls ergeben, dass der Speicherverbrauch der Archive durch die<lb/> Verwendung der Bounds erhöht wird. Das ist darauf zurück zu führen, dass wenn beim<lb/> Einfügen einer Lösung eine Bound gefunden wird, die schlechter ist als die beste bisher<lb/> gefundene Lösung, diese Lösung teilweise eingefügt wird und zusätzlich noch eine neue<lb/> konvertierte Lösung.<lb/></p>

			<p>Die Ergebnisse dieser Arbeit wurden auch mit den Ergebnissen anderer Arbeiten ver-<lb/>glichen, um zu sehen wie das Verfahren im Vergleich zu anderen abschneidet. Dabei<lb/> hat sich gezeigt dass die Bounding-Strategie mit anderen Verfahren mithalten kann und<lb/> in einigen Instanzen bessere Ergebnisse liefert.<lb/></p>

			<p>Die Ergebnisse dieser Arbeit haben gezeigt, dass die Bounding-Strategie eine Verbesserung<lb/> gegenüber dem Lösungsarchiv ohne Bounding-Strategie bringt. Ein wichtiger Punkt<lb/> bei der Bounding-Strategie ist es, eine effiziente Methode für die Boundberechung zu<lb/> finden, damit die Anzahl der erzeugten Generationen nicht zu stark abnimmt. Für an-<lb/>dere Problemstellungen könnte dieses Verfahren auch Verbesserungen bringen, wenn<lb/> eine effiziente Methode zur Boundberechnung gefunden wird.</p>


	</text>
</tei>
